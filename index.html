<!DOCTYPE html>

<html>

<head>

<meta charset=utf-8 />
<title>Lily Saxon's Treasure Hunt Map (Top Secret)</title>
<link rel="icon" href='https://raw.githubusercontent.com/sean-roelofsen/YDHPTO-Region-Geojsons/main/treasure.ico' type="image/x-icon">
<meta name="viewport" content='width=device-width, initial-scale=1, maximum-scale=1,user-scalable=no'/>



	<!--Link to Leaflet CSS document
<meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  
  -->

	<!--linking to Leaflet API, Geosearch, FontAwesome-->
	<link rel="stylesheet" href="https://unpkg.com/leaflet@1.7.1/dist/leaflet.css" />
	<link rel="stylesheet" href="https://unpkg.com/leaflet-geosearch@3.1.0/dist/geosearch.css"/>
	<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css" />
	<script src="https://unpkg.com/leaflet@1.7.1/dist/leaflet.js"></script>
	<script src="https://unpkg.com/leaflet-geosearch@3.1.0/dist/bundle.min.js"></script>

	<!--linking to jQuery and jQuery UI libraries and jQuery UI CSS stylesheet -->
	<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.5.1/jquery.min.js"></script>
	<link rel="stylesheet" href="https://ajax.googleapis.com/ajax/libs/jqueryui/1.12.1/themes/smoothness/jquery-ui.css">
	<script src="https://ajax.googleapis.com/ajax/libs/jqueryui/1.12.1/jquery-ui.min.js"></script>
  <link rel="stylesheet" href="https://raw.githubusercontent.com/stefanocudini/leaflet-gps/master/src/leaflet-gps.css" />
    <link rel="stylesheet" href="style.css" />
    <script src="https://raw.githubusercontent.com/stefanocudini/leaflet-gps/master/src/leaflet-gps.js"></script>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/leaflet-easybutton@2/src/easy-button.css">
        <script src="https://cdn.jsdelivr.net/npm/leaflet-easybutton@2/src/easy-button.js"></script>
    <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.15.3/css/all.css" />

        <link rel="stylesheet" href="Leaflet.PolylineMeasure.css" />
        <script src="Leaflet.PolylineMeasure.js"></script>


  <!--<link href="//netdna.bootstrapcdn.com/twitter-bootstrap/2.3.2/css/bootstrap-combined.no-icons.min.css" rel="stylesheet">
<link href="//netdna.bootstrapcdn.com/font-awesome/3.2.1/css/font-awesome.css" rel="stylesheet">-->

<script type="text/css"></script>
<!--<div id="map" class="map">  </div>-->

<style>
/*********************************************************
**                                                      **
**       Leaflet Plugin "Leaflet.PolylineMeasure"       **
**       File "Leaflet.PolylineMeasure.css"             **
**       Date: 2023-05-26                               **
**                                                      **
*********************************************************/


a.polyline-measure-controlOnBgColor, a.polyline-measure-controlOnBgColor:hover {
    background-color: #8f8;
}

.polyline-measure-unicode-icon {
    font-size: 19px;
    font-weight: bold;
}

a.polyline-measure-clearControl:active {
    background-color: #f88;
}

.polyline-measure-unicode-icon, .polyline-measure-clearControl, #unitControlId
{
    cursor: pointer;
}

.polyline-measure-tooltip {
    font: 10px Arial, Helvetica, sans-serif;
    line-height: 10px;
    background-color: rgba(255, 255, 170, 0.7);
    border-radius: 3px;
    box-shadow: 1px 1px 4px #888;
    margin: 0;
    padding: 2px;
    width: auto !important;
    height: auto !important;
    white-space: nowrap;
    text-align: right;
}

.polyline-measure-tooltip-end {
    background-color: rgba(255, 255, 40, 0.7);
}

.polyline-measure-tooltip-total {
    color: #006;
    font-weight: bold;
}

.polyline-measure-tooltip-difference {
    color: #060;
    font-style: italic;
}

.polyline-measure-popupTooltip {
    font: 11px Arial, Helvetica, sans-serif;
    line-height: 11px;
}

/* These rules are applied to the layer toggle in top right corner, a cleaner look than the default toggle */
.leaflet-control-layers-toggle {
  background-image: url(https://i.stack.imgur.com/3keSg.png) !important;
	background-color: #2da0e2;
  background-size: 30px 30px;
		}

	.leaflet-touch .leaflet-control-layers-toggle {
	background-image: url(https://i.stack.imgur.com/3keSg.png) !important;
	background-color: #2da0e2;
	}

.leaflet-control-layers-expanded {
  color: white;
	background-color: #2da0e2;
	}

.leaflet-control-layers-expanded {
  text-decoration: uncheck ALL;
}

/* Hide checkboxes for the 1st, 4th, and 10th layers */
.leaflet-control-layers-overlays label:nth-child(1) .leaflet-control-layers-selector,
.leaflet-control-layers-overlays label:nth-child(4) .leaflet-control-layers-selector,
.leaflet-control-layers-overlays label:nth-child(10) .leaflet-control-layers-selector {
    display: none; /* Hides the checkbox */
}

/* Optionally, disable pointer events for these labels to prevent clicking */
.leaflet-control-layers-overlays label:nth-child(1),
.leaflet-control-layers-overlays label:nth-child(4),
.leaflet-control-layers-overlays label:nth-child(10) {
    pointer-events: none;
}




	

/* set style parameters to account for Information box(list) and map (fills entire screen), with separate properties, also allows LayerControl box to not inherit the same parameters as the info box -this was the section giving me a ton of issues, with the LayerControl box opening the same size as the info box... fixed now! */
#map {
    position: absolute;
    top: 0%;
    bottom: 0%;
    width: 100%;
    scroll-behavior: zoom;
}

/*#toggle-button {
    position: absolute;
    top: 2%;
    left:  5%;
    /*bottom: 0%;
    width: 100%;
    width: 20px;*/
    /*visibility: hidden;
    height: 15px;
    border: 1px solid rgb(33,13, 40);
    
    border-radius: 1px;
    z-index: 1800;
    font-family: Tahoma;
    font-size: 8pt;
    background: #bebebe;
    cursor: pointer;
    scroll-behavior: auto;

}*/

/*
#buttonOff {
    position: fixed;
    top: 67%;
    left:  0.5%;
    /*bottom: 0%;
    width: 100%;
    width: 20px;*/
    /*visibility: hidden;
    height: 30px;
    border: 1px solid rgb(33,13, 40);
    
    border-radius: 1px;
    z-index: 1800;
    font-family: Tahoma;
    font-size: 8pt;
    background: #bebebe;
    cursor: pointer;
    scroll-behavior: auto;
}

*/

/*#buttonOn {
    position: fixed;
    top: 33%;
    left:  0.5%;
    height: 30px;
    border: 1px solid rgb(33,13, 40);
    border-radius: 1px;
    z-index: 1800;
    font-family: Tahoma;
    font-size: 8pt;
    background: #bebebe;
    cursor: pointer;
    scroll-behavior: auto;
}*/

/*
.target { 
     
    clear:both;
    position: fixed;
    left: 5%;
    top: 45px;
    width: 320px;
    /*visibility: hidden;
    height: 425px;
    opacity: 0.9;
    margin: 5px auto;
    padding: 0 15px;
    background: #d3d3d3;
    border: 2px solid rgb(33,13, 40);
    border-radius: 3px;
    z-index: 180;
    font-family: Tahoma;
    font-size: 12pt;
    display: none;
    text-decoration-color: #000000;
    scroll-behavior: auto;

}
*/
/*
.circle-with-txt {
    position: absolute;
    
    font-size: 12px;
    opacity: 0.7;
    font-weight: bold;
    color: black;
    width: 25px;
    height: 25px;
  }
  .txt {
    margin: 0;
    position: absolute;
    top: 50%;
    left: 50%;
    -ms-transform: translate(-50%, -50%);
    transform: translate(-50%, -50%);
    font-size: 12px;
  }
   
  .circle-with-txt2 {
    position: absolute;
    
    font-size: 11px;
    opacity: 0.9;
    font-weight: bold;
    color: black;
    width: 5px;
    height: 5px;
  }
  .txt2 {
    margin: 0;
    position: absolute;
    top: 50%;
    left: 50%;
    -ms-transform: translate(-50%, -50%);
    transform: translate(-50%, -50%);
    font-size: 12px;
  }*/
    
.hidden {
    display: none;
}

.leaflet-control-basemapsSwitcher{
    height: auto;
    width: auto;
    display:flex;
}

.leaflet-control-basemapsSwitcher:hover{
    cursor: pointer;
}

.basemapImg{
    box-shadow: 2px 2px 5px rgb(0 0 0 / 65%);
    background-color: #fff;
    margin:5px;
    padding:5px;
    border-radius: 3px 3px;
}

.basemapImg div{
    background-size: 55px 55px;
    width: 55px;
    height: 55px;
    border-radius: 3px 3px;
    display: flex;
    flex-direction: column;
    justify-content: space-between;
}

.basemapImg div .name{
    width:100%;
    height:auto;
    background-color: rgba(255, 255, 255, 0.6);
    border-radius: 0;
    color:black;
    display: flex;
    align-items: center;
    font-weight: 500;
    padding:1px;
}

.basemapImg div .check{
    width:auto;
    height:auto;
    border-radius: 0;
    display: flex;
    align-items: flex-end;
    font-weight: 500;
    padding:1px;
    content:''
}

.activeMap::before{
    color:white;
    content: '✔';
    width: 18px;
    height: 18px;
    background-color: #387B23;
    border-radius: 10px;
    display: flex;
    align-items: center;
    justify-content: center;
}


.custom-label-twenty {
    background-color: rgba(255, 255, 255, 0.5); /* Semi-transparent white background */
    border: 1px solid #ccc; /* Light grey border */
    padding: 2px; /* Some padding around the text */
    border-radius: 4px; /* Rounded corners */
    text-align: center; /* Center the text */
    font-size: 12px; /* Set the font size */
    z-index: 10000;
    color: #000000; /* Dark text for readability */
    pointer-events: none; /* Labels won't block map interactions */
    display: flex; /* Set display to flex */
    justify-content: center; /* Center horizontally in the flex container */
    align-items: center; /* Center vertically in the flex container */
}


.custom-label-twentyone {
    background-color: rgba(255, 255, 255, 0.5); /* Semi-transparent white background */
    border: 1px solid #ccc; /* Light grey border */
    padding: 2px; /* Some padding around the text */
    border-radius: 4px; /* Rounded corners */
    text-align: center; /* Center the text */
    font-size: 12px; /* Set the font size */
    z-index: 10000;
    color: #000000; /* Dark text for readability */
    pointer-events: none; /* Labels won't block map interactions */
    display: flex; /* Set display to flex */
    justify-content: center; /* Center horizontally in the flex container */
    align-items: center; /* Center vertically in the flex container */
}
/*#header {
    float: right;
    position: absolute;
    display: show;
    height: 450px;
    width: 200px;


    @media screen and (max-width: 768px) {
  .target{
    visibility: hidden;
    clear: both;
    float: left;
    margin: 10px auto 5px 20px;
    width: 28%;
    display: none;
}

}*/
.leaflet-container .leaflet-control-gps {
    position:relative;
    float:left;
    background:#fff;
    color:#1978cf;
    -moz-border-radius: 4px;
    -webkit-border-radius: 4px;
    border-radius: 4px;
    /*background-color: rgba(0, 0, 0, 0.25);*/
    background-color: rgba(255, 255, 255, 0.8);
    z-index:1000;   
    /*box-shadow: 0 1px 7px rgba(0,0,0,0.65);*/
    border: 2px solid rgba(0,0,0,0.2);
    background-clip: padding-box;
    margin-left:10px;
    margin-top:10px;
}
.leaflet-control-gps .gps-button {
    display:block;
    float:left;
    width:22px;
    height:22px;
    background-image: url('https://raw.githubusercontent.com/stefanocudini/leaflet-gps/master/images/gps-icon.svg');
    background-repeat: no-repeat;
    background-position: 1px 1px;
    background-color: #fff;
    border-radius:4px;
    padding: 2px;
    margin: 2px;
}
.leaflet-control-gps .gps-button:hover,
.leaflet-control-gps .gps-button.active:hover {
    background-color: #f4f4f4;
}
.leaflet-control-gps .gps-button.loading,
.leaflet-control-gps .gps-button.loading:hover {
    background-position: 1px -28px;
}
.leaflet-control-gps .gps-button.active {
    background-position: 1px -52px;
}
.leaflet-control-gps .gps-button.disabled {
    background-position: 1px -24px;
}

.leaflet-control-gps .gps-alert {
    position:absolute;
    left:34px;
    bottom:-1px;
    width:220px;
    padding:2px;
    line-height:1em;
    color:#e00;
    border: 2px solid rgba(0,0,0,0.2);
    background-color: rgba(255, 255, 255, 0.75);
    border-radius:4px;
}

/* Target the specific icon in the 'add-marker' state */
.leaflet-bar .fa-map-marker-alt {
    color: green; /* Change icon color to green */
}

/* Optional: Change the icon color on hover for better UX */
.leaflet-bar .fa-map-marker-alt:hover {
    color: darkgreen; /* Darker green on hover */
}

/* Target the specific icon in the 'add-marker' state */
.leaflet-bar .fa-info-circle {
    color: blue; /* Change icon color to green */
}

/* Optional: Change the icon color on hover for better UX */
.leaflet-bar .fa-info-circle:hover {
    color: darkblue; /* Darker green on hover */
}


/* Target the specific icon in the 'add-marker' state */
.leaflet-bar .fa-google {
    color: royalblue; /* Change icon color to green */
}

/* Optional: Change the icon color on hover for better UX */
.leaflet-bar .fa-google:hover {
    color: darkblue; /* Darker green on hover */
}


/* Target the specific icon in the 'add-marker' state */
.leaflet-bar .fa-home {
    color: saddlebrown; /* Change icon color to green */
}

/* Optional: Change the icon color on hover for better UX */
.leaflet-bar .fa-home:hover {
    color: darkbrown /* Darker green on hover */
}

/* Target the specific icon in the 'add-marker' state */
.leaflet-bar .fa-trash-alt {
    color: indianred; Change icon color to green */
}

/* Optional: Change the icon color on hover for better UX */
.leaflet-bar .fa-trash-alt:hover {
    color: darkred; /* Darker green on hover */
}

/* Add this to your CSS */
.hooray-popup {
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    z-index: 1000;
    width: 80%; /* Responsive width */
    max-width: 480px; /* Maximum width */
    background-color: white; /* or any preferred color */
    padding: 10px;
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
    text-align: center;
    border-radius: 10px;
}

.giphy-embed {
    width: 100%; /* Responsive width */
    height: auto; /* Maintain aspect ratio */
    border: none;
}

@media (max-width: 768px) {
    /* Adjustments for smaller screens */
    .hooray-popup {
        width: 90%;
    }
}




body {
    margin: 0;
    padding: 0;
  }
	
</style>
</head>


<body>

<div id="map"></div>
<!-- Place this in your HTML -->
<div id="hoorayPopup" class="hooray-popup" style="display: none;">
    <iframe src="https://giphy.com/embed/3oz8xAFtqoOUUrsh7W" width="480" height="320" frameBorder="0" class="giphy-embed" allowFullScreen></iframe>
    <button onclick="closeHoorayPopup()">Close</button>
</div>



	<script>
		var lat = 43.185;
		var lng = -79.253;
		var zoom = 14.5;
        
		//var map = L.map('map', {
			//takes off native default Leaflet API zoom control to allow for modified zoom control/home button below
		//zoomControl: false
		//	});
		  
		  //CartoDB 'Voyager with Labels' map tiles, grabs zoom and lat-long from variables listed above
//		map.setView([lat, lng], zoom);
	//		L.tileLayer('https://{s}.basemaps.cartocdn.com/rastertiles/voyager_labels_under/{z}/{x}/{y}.png', {
	//				attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors &copy; <a href="https://carto.com/attributions">CARTO</a>',
	//	subdomains: 'abcd',
 //   maxZoom: 19
	//	}).addTo(map);

   // Sets centre of map at the LatLong specified with Zoom level
      var map = L.map('map', {
          zoomControl: false,
          maxZoom:18
          
          });

        map.setView([lat, lng], zoom);
       
      // This example uses custom tiles taken from https://leaflet-extras.github.io/leaflet-providers/preview/
      //L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
     //          maxZoom: 19,
    //    attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> <a href="https://lustrous-pavlova-f6a9f7.netlify.app/" target="_blank">*Inspector List*</a>'
    // }).addTo(map);
       

/*********************************************************
**                                                      **
**       Leaflet Plugin "Leaflet.PolylineMeasure"       **
**       File "Leaflet.PolylineMeasure.js"              **
**       Date: 2022-12-28                               **
**                                                      **
*********************************************************/


(function (factory) {
    if (typeof define === 'function' && define.amd) {
        // AMD
        define(['leaflet'], factory);
    } else if (typeof module !== 'undefined') {
        // Node/CommonJS
        module.exports = factory(require('leaflet'));
    } else {
        // Browser globals
        if (typeof window.L === 'undefined') {
            throw new Error('Leaflet must be loaded first');
        }
        factory(window.L);
    }
}(function (L) {
    var _measureControlId = 'polyline-measure-control';
    var _unicodeClass = 'polyline-measure-unicode-icon';
    var isMacOS = navigator.platform === 'MacIntel';

    /**
     * Polyline Measure class
     * @extends L.Control
     */
    L.Control.PolylineMeasure = L.Control.extend({
        /**
         * Default options for the tool
         * @type {Object}
         */
        options: {
            /**
             * Position to show the control. Possible values are: 'topright', 'topleft', 'bottomright', 'bottomleft'
             * @type {String}
             * @default
             */
            position: 'topleft',
            /**
             * Default unit the distances are displayed in. Possible values are: 'kilometres', 'landmiles', 'nauticalmiles'
             * @type {String}
             * @default
             */
            unit: 'kilometres',
            /**
             * Use subunits (metres/feet) in tooltips in case of distances less then 1 kilometre/landmile
             * @type {Boolean}
             * @default
             */
            useSubunits: true,            
            /**
             * Clear all measurements when Measure Control is switched off
             * @type {Boolean}
             * @default
             */
            clearMeasurementsOnStop: true,
            /**
             * Whether bearings are displayed within the tooltips
             * @type {Boolean}
             * @default
             */
            showBearings: false,
             /**
             * Text for the bearing In
             * @type {String}
             * @default
             */
            bearingTextIn: 'In',
            /**
             * Text for the bearing Out
             * @type {String}
             * @default
             */
            bearingTextOut: 'Out',
             /**
             * Text for last point's tooltip
             * @type {String}
             * @default
             */
            tooltipTextFinish: 'Click to <b>finish line</b><br>',
            tooltipTextDelete: 'Press SHIFT-key and click to <b>delete point</b>',
            tooltipTextMove: 'Click and drag to <b>move point</b><br>',
            tooltipTextResume: '<br>Press ' + (isMacOS ? '⌘' : 'CTRL-key') + ' and click to <b>resume line</b>',
            tooltipTextAdd: 'Press ' + (isMacOS ? '⌘' : 'CTRL-key') + ' and click to <b>add point</b>',

            /**
             * Title for the control going to be switched on
             * @type {String}
             * @default
             */
            measureControlTitleOn: "Turn on PolylineMeasure",
            /**
             * Title for the control going to be switched off
             * @type {String}
             * @default
             */
            measureControlTitleOff: "Turn off PolylineMeasure",
            /**
             * Label of the Measure control (maybe a unicode symbol)
             * @type {String}
             * @default
             */
            measureControlLabel: '&#8614;',
            /**
             * Classes to apply to the Measure control
             * @type {Array}
             * @default
             */
            measureControlClasses: [],
            /**
             * Show a control to clear all the measurements
             * @type {Boolean}
             * @default
             */
            showClearControl: false,
            /**
             * Title text to show on the Clear measurements control button
             * @type {String}
             * @default
             */
            clearControlTitle: 'Clear Measurements',
            /**
             * Label of the Clear control (maybe a unicode symbol)
             * @type {String}
             * @default
             */
            clearControlLabel: '&times;',
            /**
             * Classes to apply to Clear control button
             * @type {Array}
             * @default
             */
            clearControlClasses: [],
            /**
             * Show a control to change the units of measurements
             * @type {Boolean}
             * @default
             */
            showUnitControl: false,
            /**
             * The measurement units that can be cycled through by using the Unit Control button
             * @type {Array}
             * @default
             */
            // unitControlUnits: ["kilometres" , "meterslandmiles", "nauticalmiles"],
            unitControlUnits: ["kilometres"],
            /**
             * Title texts to show on the Unit Control button
             * @type {Object}
             * @default
             */
            unitControlTitle: {
               //text: 'Change Units',
               kilometres: 'kilometres'
               //metres: 'metres'
               
            },
            //unitControlTitle: {
              // text: 'Change Units',
             //  kilometres: 'kilometres',
             //  landmiles: 'land miles',
             //  nauticalmiles: 'nautical miles'
           // },
            /**
             * Unit symbols to show in the Unit Control button and measurement labels
             * @type {Object}
             * @default
             */
            unitControlLabel: {
               metres: 'm',
               kilometres: 'km'
               
            },
            //unitControlLabel: {
              // metres: 'm',
              // kilometres: 'km',
              // feet: 'ft',
               //landmiles: 'mi',
               //nauticalmiles: 'nm'
            //},
            /**
             * Classes to apply to the Unit control
             * @type {Array}
             * @default
             */
            unitControlClasses: [],

            /**
             * Styling settings for the temporary dashed rubberline
             * @type {Object}
             */
            tempLine: {
                /**
                 * Dashed line color
                 * @type {String}
                 * @default
                 */
                color: '#00f',
                /**
                 * Dashed line weight
                 * @type {Number}
                 * @default
                 */
                weight: 2
            },
            /**
             * Styling for the fixed polyline
             * @type {Object}
             */
            fixedLine: {
                /**
                 * Solid line color
                 * @type {String}
                 * @default
                 */
                color: '#006',
                /**
                 * Solid line weight
                 * @type {Number}
                 * @default
                 */
                weight: 2
            },
            /**
             * Styling of the midway arrow 
             * @type {Object}
             */
            arrow: {
                /**
                 * Color of the arrow
                 * @type {String}
                 * @default
                 */
                color: '#000'
            },            
            /**
             * Style settings for circle marker indicating the starting point of the polyline
             * @type {Object}
             */
            startCircle: {
                /**
                 * Color of the border of the circle
                 * @type {String}
                 * @default
                 */
                color: '#000',
                /**
                 * Weight of the circle
                 * @type {Number}
                 * @default
                 */
                weight: 1,
                /**
                 * Fill color of the circle
                 * @type {String}
                 * @default
                 */
                fillColor: '#0f0',
                /**
                 * Fill opacity of the circle
                 * @type {Number}
                 * @default
                 */
                fillOpacity: 1,
                /**
                 * Radius of the circle
                 * @type {Number}
                 * @default
                 */
                radius: 3
            },
            /**
             * Style settings for all circle markers between startCircle and endCircle
             * @type {Object}
             */
            intermedCircle: {
                /**
                 * Color of the border of the circle
                 * @type {String}
                 * @default
                 */
                color: '#000',
                /**
                 * Weight of the circle
                 * @type {Number}
                 * @default
                 */
                weight: 1,
                /**
                 * Fill color of the circle
                 * @type {String}
                 * @default
                 */
                fillColor: '#ff0',
                /**
                 * Fill opacity of the circle
                 * @type {Number}
                 * @default
                 */
                fillOpacity: 1,
                /**
                 * Radius of the circle
                 * @type {Number}
                 * @default
                 */
                radius: 3
            },
            /**
             * Style settings for circle marker indicating the latest point of the polyline during drawing a line
             * @type {Object}
             */
            currentCircle: {
                /**
                 * Color of the border of the circle
                 * @type {String}
                 * @default
                 */
                color: '#000',
                /**
                 * Weight of the circle
                 * @type {Number}
                 * @default
                 */
                weight: 1,
                /**
                 * Fill color of the circle
                 * @type {String}
                 * @default
                 */
                fillColor: '#f0f',
                /**
                 * Fill opacity of the circle
                 * @type {Number}
                 * @default
                 */
                fillOpacity: 1,
                /**
                 * Radius of the circle
                 * @type {Number}
                 * @default
                 */
                radius: 6
            },
            /**
             * Style settings for circle marker indicating the end point of the polyline
             * @type {Object}
             */
            endCircle: {
                /**
                 * Color of the border of the circle
                 * @type {String}
                 * @default
                 */
                color: '#000',
                /**
                 * Weight of the circle
                 * @type {Number}
                 * @default
                 */
                weight: 1,
                /**
                 * Fill color of the circle
                 * @type {String}
                 * @default
                 */
                fillColor: '#f00',
                /**
                 * Fill opacity of the circle
                 * @type {Number}
                 * @default
                 */
                fillOpacity: 1,
                /**
                 * Radius of the circle
                 * @type {Number}
                 * @default
                 */
                radius: 3
            }
        },

        _arcpoints: 99,  // 99 points = 98 line segments. lower value to make arc less accurate or increase value to make it more accurate.
        _circleNr: -1,
        _lineNr: -1,

        /**
         * Create a control button
         * @param {String}      label           Label to add
         * @param {String}      title           Title to show on hover
         * @param {Array}       classesToAdd    Collection of classes to add
         * @param {Element}     container       Parent element
         * @param {Function}    fn              Callback function to run
         * @param {Object}      context         Context
         * @returns {Element}                   Created element
         * @private
         */
        _createControl: function (label, title, classesToAdd, container, fn, context) {
            var anchor = document.createElement('a');
            anchor.innerHTML = label;
            anchor.setAttribute('title', title);
            classesToAdd.forEach(function(c) {
                anchor.classList.add(c);
            });
            L.DomEvent.on (anchor, 'click', fn, context);
            container.appendChild(anchor);
            return anchor;
        },

        /**
         * Method to fire on add to map
         * @param {Object}      map     Map object
         * @returns {Element}           Containing element
         */
        onAdd: function(map) {
            var self = this
            // needed to avoid creating points by mouseclick during dragging the map
            map.on('movestart ', function() {
              self._mapdragging = true
            })
            this._container = document.createElement('div');
            this._container.classList.add('leaflet-bar');
            L.DomEvent.disableClickPropagation(this._container); // otherwise drawing process would instantly start at controls' container or double click would zoom-in map
            var title = this.options.measureControlTitleOn;
            var label = this.options.measureControlLabel;
            var classes = this.options.measureControlClasses;
            if (label.indexOf('&') != -1) {
                classes.push(_unicodeClass);
            }

            // initialize state
            this._arrPolylines = [];
            this._measureControl = this._createControl (label, title, classes, this._container, this._toggleMeasure, this);
            this._defaultControlBgColor = this._measureControl.style.backgroundColor;
            this._measureControl.setAttribute('id', _measureControlId);
            if (this.options.showClearControl) {
                var title = this.options.clearControlTitle;
                var label = this.options.clearControlLabel;
                var classes = this.options.clearControlClasses;
                if (label.indexOf('&') != -1) {
                    classes.push(_unicodeClass);
                }
                this._clearMeasureControl = this._createControl (label, title, classes, this._container, this._clearAllMeasurements, this);
                this._clearMeasureControl.classList.add('polyline-measure-clearControl')
            }

            // There is no point in using the unitControl if there are no units to choose from.
            if (this.options.showUnitControl && this.options.unitControlUnits.length > 1) {
                var label = this.options.unitControlLabel[this.options.unit];
                var title = this.options.unitControlTitle.text + " [" + this.options.unitControlTitle[this.options.unit]  + "]";

                var classes = this.options.unitControlClasses;
                this._unitControl = this._createControl (label, title, classes, this._container, this._changeUnit, this);
                this._unitControl.setAttribute ('id', 'unitControlId');
            }
            return this._container;
        },

        /**
         * Method to fire on remove from map
         */
        onRemove: function () {
            if (this._measuring) {
                this._toggleMeasure();
            }
        },

        // turn off all Leaflet-own events of markers (popups, tooltips). Needed to allow creating points on top of markers
        _saveNonpolylineEvents: function () {
            this._nonpolylineTargets = this._map._targets;
            if (typeof this._polylineTargets !== 'undefined') {
                this._map._targets = this._polylineTargets;
            } else {
                this._map._targets ={};
            }
        },

        // on disabling the measure add-on, save Polyline-measure events and enable the former Leaflet-own events again
        _savePolylineEvents: function () {
                this._polylineTargets = this._map._targets;
                this._map._targets = this._nonpolylineTargets;
        },

        /**
         * Toggle the measure functionality on or off
         * @private
         */
        _toggleMeasure: function () {
            this._measuring = !this._measuring;
            if (this._measuring) {   // if measuring is going to be switched on
                this._mapdragging = false;
                this._saveNonpolylineEvents ();
                this._measureControl.classList.add ('polyline-measure-controlOnBgColor');
                this._measureControl.style.backgroundColor = this.options.backgroundColor;
                this._measureControl.title = this.options.measureControlTitleOff;
                this._oldCursor = this._map._container.style.cursor;          // save former cursor type
                this._map._container.style.cursor = 'crosshair';
                this._doubleClickZoom = this._map.doubleClickZoom.enabled();  // save former status of doubleClickZoom
                this._map.doubleClickZoom.disable();
                // create LayerGroup "layerPaint" (only) the first time Measure Control is switched on
                if (!this._layerPaint) {
                    this._layerPaint = L.layerGroup().addTo(this._map);
                }
                this._map.on ('mousemove', this._mouseMove, this);   //  enable listing to 'mousemove', 'click', 'keydown' events
                this._map.on ('click', this._mouseClick, this);
                L.DomEvent.on (document, 'keydown', this._onKeyDown, this);
                this._resetPathVariables();
            } else {   // if measuring is going to be switched off
                this._savePolylineEvents ();
                this._measureControl.classList.remove ('polyline-measure-controlOnBgColor');
                this._measureControl.style.backgroundColor = this._defaultControlBgColor;
                this._measureControl.title = this.options.measureControlTitleOn;
                this._map._container.style.cursor = this._oldCursor;
                this._map.off ('mousemove', this._mouseMove, this);
                this._map.off ('click', this._mouseClick, this);
                this._map.off ('mousemove', this._resumeFirstpointMousemove, this);
                this._map.off ('click', this._resumeFirstpointClick, this);
                this._map.off ('mousemove', this._dragCircleMousemove, this);
                this._map.off ('mouseup', this._dragCircleMouseup, this);
                L.DomEvent.off (document, 'keydown', this._onKeyDown, this);
                if(this._doubleClickZoom) {
                    this._map.doubleClickZoom.enable();
                }
                if(this.options.clearMeasurementsOnStop && this._layerPaint) {
                    this._clearAllMeasurements();
                }
                // to remove temp. Line if line at the moment is being drawn and not finished while clicking the control
                if (this._cntCircle !== 0) {
                    this._finishPolylinePath();
                }
            }
            // allow easy to connect the measure control to the app, f.e. to disable the selection on the map when the measurement is turned on
            this._map.fire('polylinemeasure:toggle', { status: this._measuring });
        },

        /**
         * Clear all measurements from the map
         */
        _clearAllMeasurements: function() {
            if ((this._cntCircle !== undefined) && (this._cntCircle !== 0)) {
                    this._finishPolylinePath();
            }
            if (this._layerPaint) {
                this._layerPaint.clearLayers();
            }
            this._arrPolylines = [];
            this._map.fire('polylinemeasure:clear');
        },

        _changeUnit: function() {
            // Retrieve the index of the next available unit of measurement.
            let indexCurrUnit = this.options.unitControlUnits.indexOf(this.options.unit);
            let indexNextUnit = (indexCurrUnit+1)%this.options.unitControlUnits.length;

            // Update the unit of measurement.
            this.options.unit = this.options.unitControlUnits[indexNextUnit];
            this._unitControl.innerHTML = this.options.unitControlLabel[this.options.unit];
            this._unitControl.title = this.options.unitControlTitle.text +" [" + this.options.unitControlTitle[this.options.unit]  + "]";

            if (this._currentLine) {
                this._computeDistance(this._currentLine);
            }
            this._arrPolylines.map (this._computeDistance.bind(this));
        },

        _computeDistance: function(line) {
            var totalDistance = 0;
            line.circleCoords.map (function(point, point_index) {
                if (point_index >= 1) {
                    var distance = line.circleCoords [point_index - 1].distanceTo (line.circleCoords [point_index]);
                    totalDistance += distance;
                    this._updateTooltip (line.tooltips [point_index], line.tooltips [point_index - 1], totalDistance, distance, line.circleCoords [point_index - 1], line.circleCoords [point_index]);
                }
            }.bind(this));
        },

        /**
         * Event to fire when a keyboard key is depressed.
         * Currently only watching for ESC key (= keyCode 27). 1st press finishes line, 2nd press turns Measuring off.
         * @param {Object} e Event
         * @private
         */
        _onKeyDown: function (e) {
            if (e.keyCode === 27) {
                // if resuming a line at its first point is active
                if (this._resumeFirstpointFlag === true) {
                    this._resumeFirstpointFlag = false;
                    var lineNr = this._lineNr;
                    this._map.off ('mousemove', this._resumeFirstpointMousemove, this);
                    this._map.off ('click', this._resumeFirstpointClick, this);
                    this._layerPaint.removeLayer (this._rubberlinePath2);
                    this._layerPaint.removeLayer (this._tooltipNew);
                    this._arrPolylines[lineNr].circleMarkers [0].setStyle (this.options.startCircle);
                    var text = '';
                    var totalDistance = 0;
                    if (this.options.showBearings === true) {
                        text = this.options.bearingTextIn+':---°<br>'+this.options.bearingTextOut+':---°';
                    }
                    text = text + '<div class="polyline-measure-tooltip-difference">+' + '0</div>';
                    text = text + '<div class="polyline-measure-tooltip-total">' + '0</div>';
                    this._arrPolylines[lineNr].tooltips [0]._icon.innerHTML = text;
                    this._arrPolylines[lineNr].tooltips.map (function (item, index) {
                        if (index >= 1) {
                            var distance = this._arrPolylines[lineNr].circleCoords[index-1].distanceTo (this._arrPolylines[lineNr].circleCoords[index]);
                            var lastCircleCoords = this._arrPolylines[lineNr].circleCoords[index - 1];
                            var mouseCoords = this._arrPolylines[lineNr].circleCoords[index];
                            totalDistance += distance;
                            var prevTooltip = this._arrPolylines[lineNr].tooltips[index-1]
                            this._updateTooltip (item, prevTooltip, totalDistance, distance, lastCircleCoords, mouseCoords);
                        }
                    }.bind (this));
                    this._map.on ('mousemove', this._mouseMove, this);
                    return
                }
                if (!this._currentLine) {    // if NOT drawing a line, ESC will directly switch of measuring
                    this._toggleMeasure();
                } else {                     // if drawing a line, ESC will finish the current line
                    this._finishPolylinePath(e);
                }
            }
        },

        /**
         * Get the distance in the format specified in the options
         * @param {Number} distance Distance to convert
         * @returns {{value: *, unit: *}}
         * @private
         */
        _getDistance: function (distance) {
            var dist = distance;
            var unit;
            if (this.options.unit === 'nauticalmiles') {
                unit = this.options.unitControlLabel.nauticalmiles;
                if (dist >= 185200) {
                    dist = (dist/1852).toFixed(0);
                } else if (dist >= 18520) {
                    dist = (dist/1852).toFixed(1);
                } else if (dist >= 1852) {
                    dist = (dist/1852).toFixed(2);
                } else  {
                    dist = (dist/1852).toFixed(3);   // there's no subunit of Nautical Miles for horizontal length measurements. "Cable length" (1/10th of 1 nm) is rarely used
                }
            } else if (this.options.unit === 'landmiles') {
                unit = this.options.unitControlLabel.landmiles;
                if (dist >= 160934.4) {
                    dist = (dist/1609.344).toFixed(0);
                } else if (dist >= 16093.44) {
                    dist = (dist/1609.344).toFixed(1);
                } else if (dist >= 1609.344) {
                    dist = (dist/1609.344).toFixed(2);
                } else {
                    if (!this.options.useSubunits) {
                        dist = (dist/1609.344).toFixed(3);
                    } else {
                        dist = (dist/0.3048).toFixed(0);
                        unit = this.options.unitControlLabel.feet;
                    }
                }
            }
            else {
                unit = this.options.unitControlLabel.kilometres;
                if (dist >= 100000) {
                    dist = (dist/1000).toFixed(0);
                } else if (dist >= 10000) {
                    dist = (dist/1000).toFixed(1);
                } else if (dist >= 1000) {
                    dist = (dist/1000).toFixed(2);
                } else {
                    if (!this.options.useSubunits) {
                        dist = (dist/1000).toFixed(3);
                    } else {
                        dist = (dist).toFixed(0);
                        unit = this.options.unitControlLabel.metres;
                    }
                }
            }
            return {value:dist, unit:unit};
        },

        /**
         * Calculate Great-circle Arc (= shortest distance on a sphere like the Earth) between two coordinates
         * formulas: http://www.edwilliams.org/avform.htm
         * @private
         */
        _polylineArc: function (_from, _to) {

            function _GCinterpolate (f) {
                var A = Math.sin((1 - f) * d) / Math.sin(d);
                var B = Math.sin(f * d) / Math.sin(d);
                var x = A * Math.cos(fromLat) * Math.cos(fromLng) + B * Math.cos(toLat) * Math.cos(toLng);
                var y = A * Math.cos(fromLat) * Math.sin(fromLng) + B * Math.cos(toLat) * Math.sin(toLng);
                var z = A * Math.sin(fromLat) + B * Math.sin(toLat);
                // atan2 better than atan-function cause results are from -pi to +pi
                // => results of latInterpol, lngInterpol always within range -180° ... +180°  => conversion into values < -180° or > + 180° has to be done afterwards
                var latInterpol = 180 / Math.PI * Math.atan2(z, Math.sqrt(Math.pow(x, 2) + Math.pow(y, 2)));
                var lngInterpol = 180 / Math.PI * Math.atan2(y, x);
                // don't split polyline if it crosses dateline ( -180° or +180°).  Without the polyline would look like: +179° ==> +180° ==> -180° ==> -179°...
                // algo: if difference lngInterpol-from.lng is > 180° there's been an unwanted split from +180 to -180 cause an arc can never span >180°
                var diff = lngInterpol-fromLng*180/Math.PI;
                function trunc(n) { return Math[n > 0 ? "floor" : "ceil"](n); }   // alternatively we could use the new Math.trunc method, but Internet Explorer doesn't know it
                if (diff < 0) {
                    lngInterpol = lngInterpol  - trunc ((diff - 180)/ 360) * 360;
                } else {
                    lngInterpol = lngInterpol  - trunc ((diff +180)/ 360) * 360;
                }
                return [latInterpol, lngInterpol];
            }

            function _GCarc (npoints) {
                var arrArcCoords = [];
                var delta = 1.0 / (npoints-1 );
                // first point of Arc should NOT be returned
                for (var i = 0; i < npoints; i++) {
                    var step = delta * i;
                    var coordPair = _GCinterpolate (step);
                    arrArcCoords.push (coordPair);
                }
                return arrArcCoords;
            }

            var fromLat = _from.lat;  // work with with copies of object's elements _from.lat and _from.lng, otherwise they would get modiefied due to call-by-reference on Objects in Javascript
            var fromLng = _from.lng;
            var toLat = _to.lat;
            var toLng = _to.lng;
            fromLat=fromLat * Math.PI / 180;
            fromLng=fromLng * Math.PI / 180;
            toLat=toLat * Math.PI / 180;
            toLng=toLng * Math.PI / 180;
            var d = 2.0 * Math.asin(Math.sqrt(Math.pow (Math.sin((fromLat - toLat) / 2.0), 2) + Math.cos(fromLat) *  Math.cos(toLat) *  Math.pow(Math.sin((fromLng - toLng) / 2.0), 2)));
            var arrLatLngs;
            if (d === 0) {
                arrLatLngs = [[fromLat, fromLng]];
            } else {
                arrLatLngs = _GCarc(this._arcpoints);
            }
            return arrLatLngs;
        },

        /**
         * Update the tooltip distance
         * @param {Number} total        Total distance
         * @param {Number} difference   Difference in distance between 2 points
         * @private
         */
        _updateTooltip: function (currentTooltip, prevTooltip, total, difference, lastCircleCoords, mouseCoords) {
            // Explanation of formula: http://www.movable-type.co.uk/scripts/latlong.html
            var calcAngle = function (p1, p2, direction) {
                var lat1 = p1.lat / 180 * Math.PI;
                var lat2 = p2.lat / 180 * Math.PI;
                var lng1 = p1.lng / 180 * Math.PI;
                var lng2 = p2.lng / 180 * Math.PI;
                var y = Math.sin(lng2-lng1) * Math.cos(lat2);
                var x = Math.cos(lat1)*Math.sin(lat2) - Math.sin(lat1)*Math.cos(lat2)*Math.cos(lng2-lng1);
                if (direction === "inbound") {
                    var brng = (Math.atan2(y, x) * 180 / Math.PI + 180).toFixed(0);
                } else {
                    var brng = (Math.atan2(y, x) * 180 / Math.PI + 360).toFixed(0);
                }
                return (brng % 360);
            }

            var angleIn = calcAngle (mouseCoords, lastCircleCoords, "inbound");
            var angleOut = calcAngle (lastCircleCoords, mouseCoords, "outbound");
            var totalRound = this._getDistance (total);
            var differenceRound = this._getDistance (difference);
            var textCurrent = '';
            if (differenceRound.value > 0 ) {
                if (this.options.showBearings === true) {
                     textCurrent = this.options.bearingTextIn + ': ' + angleIn + '°<br>'+this.options.bearingTextOut+':---°';
                }
                textCurrent += '<div class="polyline-measure-tooltip-difference">+' + differenceRound.value + '&nbsp;' +  differenceRound.unit + '</div>';
            }
            textCurrent += '<div class="polyline-measure-tooltip-total">' + totalRound.value + '&nbsp;' +  totalRound.unit + '</div>';
            currentTooltip._icon.innerHTML = textCurrent;
            if ((this.options.showBearings === true) && (prevTooltip)) {
                var textPrev = prevTooltip._icon.innerHTML;
                var regExp = new RegExp(this.options.bearingTextOut + '.*\°');
                var textReplace = textPrev.replace(regExp, this.options.bearingTextOut + ': ' + angleOut + "°");
                prevTooltip._icon.innerHTML = textReplace;
            }
        },

        _drawArrow: function (arcLine) {
            // center of Great-circle distance, NOT of the arc on a Mercator map! reason: a) to complicated b) map not always Mercator c) good optical feature to see where real center of distance is not the "virtual" warped arc center due to Mercator projection            
            // differ between even and odd pointed Arcs. If even the arrow is in the center of the middle line-segment, if odd it is on the middle point
            var midpoint = Math.trunc(arcLine.length/2);
            if (arcLine.length % 2 == 0) {
                var P1 = arcLine[midpoint-1];
                var P2 = arcLine[midpoint];
                var diffLng12 = P2[1] - P1[1];
                var diffLat12 = P2[0] - P1[0];
                var center = [P1[0] + diffLat12/2, P1[1] + diffLng12/2];
            } else {
                var P1 = arcLine[midpoint-1];
                var P2 = arcLine[midpoint+1];
                var diffLng12 = P2[1] - P1[1];
                var diffLat12 = P2[0] - P1[0];
                var center = arcLine[midpoint];
            }
            // angle just an aprroximation, which could be somewhat off if Line runs near high latitudes. Use of *geographical coords* for line segment P1 to P2 is best method. Use of *Pixel coords* for just one arc segement P1 to P2 could create for short lines unexact rotation angles, and the use Use of Pixel coords between endpoints [0] to [98] (in case of 99-point-arc) results in even more rotation difference for high latitudes as with geogrpaphical coords-method
            var cssAngle = -Math.atan2(diffLat12, diffLng12)*57.29578   // convert radiant to degree as needed for use as CSS value; cssAngle is opposite to mathematical angle.
            var iconArrow = L.divIcon ({
                className: "",  // to avoid getting a default class with paddings and borders assigned by Leaflet
                iconSize: [16, 16],
                iconAnchor: [8, 8],
                    // html : "<img src='iconArrow.png' style='background:green; height:100%; vertical-align:top; transform:rotate("+ cssAngle +"deg)'>"  <<=== alternative method by the use of an image instead of a Unicode symbol.
                html : "<div style = 'color:" + this.options.arrow.color + "; font-size: 16px; line-height: 16px; vertical-align:top; transform: rotate("+ cssAngle +"deg)'>&#x27a4;</div>"   // best results if iconSize = font-size = line-height and iconAnchor font-size/2 .both values needed to position symbol in center of L.divIcon for all font-sizes.
            });
            var newArrowMarker = L.marker (center, {icon: iconArrow, zIndexOffset:-50}).addTo(this._layerPaint);  // zIndexOffset to draw arrows below tooltips
            if (!this._currentLine){  // just bind tooltip if not drawing line anymore, cause following the instruction of tooltip is just possible when not drawing a line
                newArrowMarker.bindTooltip (this.options.tooltipTextAdd, {direction:'top', opacity:0.7, className:'polyline-measure-popupTooltip'});
            }
            newArrowMarker.on ('click', this._clickedArrow, this);
            return newArrowMarker;
        },

        /**
         * Event to fire on mouse move
         * @param {Object} e Event
         * @private
         */
        _mouseMove: function (e) {
            var mouseCoords = e.latlng;
            this._map.on ('click', this._mouseClick, this);  // necassary for _dragCircle. If switched on already within _dragCircle an unwanted click is fired at the end of the drag.
            if(!mouseCoords || !this._currentLine) {
                return;
            }
            var lastCircleCoords = this._currentLine.circleCoords.last();
            this._rubberlinePath.setLatLngs (this._polylineArc (lastCircleCoords, mouseCoords));
            var currentTooltip = this._currentLine.tooltips.last();
            var prevTooltip = this._currentLine.tooltips.slice(-2,-1)[0];
            currentTooltip.setLatLng (mouseCoords);
            var distanceSegment = mouseCoords.distanceTo (lastCircleCoords);
            this._updateTooltip (currentTooltip, prevTooltip, this._currentLine.distance + distanceSegment, distanceSegment, lastCircleCoords, mouseCoords);
        },

        _startLine: function (clickCoords) {
            var icon = L.divIcon({
                className: 'polyline-measure-tooltip',
                iconAnchor: [-4, -4]
            });
            var last = function() {
                return this.slice(-1)[0];
            };
            this._rubberlinePath = L.polyline ([], {
                // Style of temporary, dashed line while moving the mouse
                color: this.options.tempLine.color,
                weight: this.options.tempLine.weight,
                interactive: false,
                dashArray: '8,8'
            }).addTo(this._layerPaint).bringToBack();

            var polylineState = this;   // use "polylineState" instead of "this" to allow measuring on 2 different maps the same time

            this._currentLine = {
                id: 0,
                circleCoords: [],
                circleMarkers: [],
                arrowMarkers: [],
                tooltips: [],
                distance: 0,

                polylinePath: L.polyline([], {
                    // Style of fixed, polyline after mouse is clicked
                    color: this.options.fixedLine.color,
                    weight: this.options.fixedLine.weight,
                    interactive: false
                }).addTo(this._layerPaint).bringToBack(),

                handleMarkers: function (latlng) {
                    // update style on previous marker
                    var lastCircleMarker = this.circleMarkers.last();
                    if (lastCircleMarker) {
                        lastCircleMarker.bindTooltip (polylineState.options.tooltipTextDelete, {direction:'top', opacity:0.7, className:'polyline-measure-popupTooltip'});
                        lastCircleMarker.off ('click', polylineState._finishPolylinePath, polylineState);
                        if (this.circleMarkers.length === 1) {
                            lastCircleMarker.setStyle (polylineState.options.startCircle);
                        } else {
                            lastCircleMarker.setStyle (polylineState.options.intermedCircle);
                        }
                    }
                    var newCircleMarker = new L.CircleMarker (latlng, polylineState.options.currentCircle).addTo(polylineState._layerPaint);
                    newCircleMarker.bindTooltip (polylineState.options.tooltipTextFinish + polylineState.options.tooltipTextDelete, {direction:'top', opacity:0.7, className:'polyline-measure-popupTooltip'});
                    newCircleMarker.cntLine = polylineState._currentLine.id;
                    newCircleMarker.cntCircle = polylineState._cntCircle;
                    polylineState._cntCircle++;
                    newCircleMarker.on ('mousedown', polylineState._dragCircle, polylineState);
                    newCircleMarker.on ('click', polylineState._finishPolylinePath, polylineState);
                    this.circleMarkers.push (newCircleMarker);
                },

                getNewToolTip: function(latlng) {
                    return L.marker (latlng, {
                        icon: icon,
                        interactive: false
                    });
                },

                addPoint: function (mouseCoords) {
                    var lastCircleCoords = this.circleCoords.last();
                    if (lastCircleCoords && lastCircleCoords.equals (mouseCoords)) {    // don't add a new circle if the click was onto the last circle
                        return;
                    }
                    this.circleCoords.push (mouseCoords);
                    // update polyline
                    if (this.circleCoords.length > 1) {
                        var arc = polylineState._polylineArc (lastCircleCoords, mouseCoords);
                        var arrowMarker = polylineState._drawArrow (arc);
                        if (this.circleCoords.length > 2) {
                            arc.shift();  // remove first coordinate of the arc, cause it is identical with last coordinate of previous arc
                        }
                        this.polylinePath.setLatLngs (this.polylinePath.getLatLngs().concat(arc));
                        // following lines needed especially for Mobile Browsers where we just use mouseclicks. No mousemoves, no tempLine.
                        arrowMarker.cntLine = polylineState._currentLine.id;
                        arrowMarker.cntArrow = polylineState._cntCircle - 1;
                        polylineState._currentLine.arrowMarkers.push (arrowMarker);
                        var distanceSegment = lastCircleCoords.distanceTo (mouseCoords);
                        this.distance += distanceSegment;
                        var currentTooltip = polylineState._currentLine.tooltips.last();
                        var prevTooltip = polylineState._currentLine.tooltips.slice(-1,-2)[0];
                        polylineState._updateTooltip (currentTooltip, prevTooltip, this.distance, distanceSegment, lastCircleCoords, mouseCoords);
                    }
                    // update last tooltip with final value
                    if (currentTooltip) {
                        currentTooltip.setLatLng (mouseCoords);
                    }
                    // add new tooltip to update on mousemove
                    var tooltipNew = this.getNewToolTip(mouseCoords);
                    tooltipNew.addTo(polylineState._layerPaint);
                    this.tooltips.push (tooltipNew);
                    this.handleMarkers (mouseCoords);
                },

                finalize: function() {
                    // remove tooltip created by last click
                    polylineState._layerPaint.removeLayer (this.tooltips.last());
                    this.tooltips.pop();
                    // remove temporary rubberline
                    polylineState._layerPaint.removeLayer (polylineState._rubberlinePath);
                    if (this.circleCoords.length > 1) {
                        this.tooltips.last()._icon.classList.add('polyline-measure-tooltip-end'); // add Class e.g. another background-color to the Previous Tooltip (which is the last fixed tooltip, cause the moving tooltip is being deleted later)
                        var lastCircleMarker = this.circleMarkers.last()
                        lastCircleMarker.setStyle (polylineState.options.endCircle);
                        // use Leaflet's own tooltip method to shwo a popuo tooltip if user hovers the last circle of a polyline
                        lastCircleMarker.unbindTooltip ();  // to close the opened Tooltip after it's been opened after click onto point to finish the line
                        polylineState._currentLine.circleMarkers.map (function (circle) {circle.bindTooltip (polylineState.options.tooltipTextMove + polylineState.options.tooltipTextDelete, {direction:'top', opacity:0.7, className:'polyline-measure-popupTooltip'})});
                        polylineState._currentLine.circleMarkers[0].bindTooltip (polylineState.options.tooltipTextMove + polylineState.options.tooltipTextDelete + polylineState.options.tooltipTextResume, {direction:'top', opacity:0.7, className:'polyline-measure-popupTooltip'});
                        lastCircleMarker.bindTooltip (polylineState.options.tooltipTextMove + polylineState.options.tooltipTextDelete + polylineState.options.tooltipTextResume, {direction:'top', opacity:0.7, className:'polyline-measure-popupTooltip'});
                        polylineState._currentLine.arrowMarkers.map (function (arrow) {arrow.bindTooltip (polylineState.options.tooltipTextAdd, {direction:'top', opacity:0.7, className:'polyline-measure-popupTooltip'})});
                        lastCircleMarker.off ('click', polylineState._finishPolylinePath, polylineState);
                        lastCircleMarker.on ('click', polylineState._resumePolylinePath, polylineState);
                        polylineState._arrPolylines.push(this);
                    } else {
                        // if there is only one point, just clean it up
                        polylineState._layerPaint.removeLayer (this.circleMarkers.last());
                        polylineState._layerPaint.removeLayer (this.tooltips.last());
                    }
                    polylineState._resetPathVariables();
                }
            };

            var firstTooltip = L.marker (clickCoords, {
                icon: icon,
                interactive: false
            })
            firstTooltip.addTo(this._layerPaint);
            var text = '';
            if (this.options.showBearings === true) {
                text = this.options.bearingTextIn+':---°<br>'+this.options.bearingTextOut+':---°';
            }
            text = text + '<div class="polyline-measure-tooltip-difference">+' + '0</div>';
            text = text + '<div class="polyline-measure-tooltip-total">' + '0</div>';
            firstTooltip._icon.innerHTML = text;
            this._currentLine.tooltips.push (firstTooltip);
            this._currentLine.circleCoords.last = last;
            this._currentLine.tooltips.last = last;
            this._currentLine.circleMarkers.last = last;
            this._currentLine.id = this._arrPolylines.length;
        },

        /**
         * Event to fire on mouse click
         * @param {Object} e Event
         * @private
         */
        _mouseClick: function (e) {
            // skip if there are no coords provided by the event, or this event's screen coordinates match those of finishing CircleMarker for the line we just completed
            if (!e.latlng || (this._finishCircleScreencoords && this._finishCircleScreencoords.equals(e.containerPoint))) {
                return;
            }

            if (!this._currentLine && !this._mapdragging) {
                this._startLine (e.latlng);
                this._map.fire('polylinemeasure:start', this._currentLine);
            }
            // just create a point if the map isn't dragged during the mouseclick.
            if (!this._mapdragging) {
                this._currentLine.addPoint (e.latlng);
                this._map.fire('polylinemeasure:add', e);
                this._map.fire('polylinemeasure:change', this._currentLine);
            } else {
                this._mapdragging = false; // this manual setting to "false" needed, instead of a "moveend"-Event. Cause the mouseclick of a "moveend"-event immediately would create a point too the same time.
            }
        },

        /**
         * Finish the drawing of the path by clicking onto the last circle or pressing ESC-Key
         * @private
         */
        _finishPolylinePath: function (e) {
            this._map.fire('polylinemeasure:finish', this._currentLine);
            this._currentLine.finalize();
            if (e) {
                this._finishCircleScreencoords = e.containerPoint;
            }
        },

        /**
         * Resume the drawing of a polyline by pressing CTRL-Key and clicking onto the last circle
         * @private
         */
        _resumePolylinePath: function (e) {
            if (e.originalEvent.ctrlKey === true || e.originalEvent.metaKey === true) {    // just resume if user pressed the CTRL-Key (or metaKey on Mac) while clicking onto the last circle
                this._currentLine = this._arrPolylines [e.target.cntLine];
                this._rubberlinePath = L.polyline ([], {
                    // Style of temporary, rubberline while moving the mouse
                    color: this.options.tempLine.color,
                    weight: this.options.tempLine.weight,
                    interactive: false,
                    dashArray: '8,8'
                }).addTo(this._layerPaint).bringToBack();
                this._currentLine.tooltips.last()._icon.classList.remove ('polyline-measure-tooltip-end');   // remove extra CSS-class of previous, last tooltip
                var tooltipNew = this._currentLine.getNewToolTip (e.latlng);
                tooltipNew.addTo (this._layerPaint);
                this._currentLine.tooltips.push(tooltipNew);
                this._currentLine.circleMarkers.last().unbindTooltip();   // remove popup-tooltip of previous, last circleMarker
                this._currentLine.circleMarkers.last().bindTooltip (this.options.tooltipTextMove + this.options.tooltipTextDelete, {direction:'top', opacity:0.7, className:'polyline-measure-popupTooltip'});
                this._currentLine.circleMarkers.last().setStyle (this.options.currentCircle);
                this._cntCircle = this._currentLine.circleCoords.length;
                this._map.fire('polylinemeasure:resume', this._currentLine);
            }
        },

        /**
         * After completing a path, reset all the values to prepare in creating the next polyline measurement
         * @private
         */
        _resetPathVariables: function() {
            this._cntCircle = 0;
            this._currentLine = null;
        },

        _clickedArrow: function(e) {
            if (e.originalEvent.ctrlKey || e.originalEvent.metaKey) {  // (metaKey for Mac)
                var lineNr = e.target.cntLine;
                var arrowNr = e.target.cntArrow;
                this._arrPolylines[lineNr].arrowMarkers [arrowNr].removeFrom (this._layerPaint);
                var newCircleMarker = new L.CircleMarker (e.latlng, this.options.intermedCircle).addTo(this._layerPaint);
                newCircleMarker.cntLine = lineNr;
                newCircleMarker.on ('mousedown', this._dragCircle, this);
                newCircleMarker.bindTooltip (this.options.tooltipTextMove + this.options.tooltipTextDelete, {direction:'top', opacity:0.7, className:'polyline-measure-popupTooltip'});
                this._arrPolylines[lineNr].circleMarkers.splice (arrowNr+1, 0, newCircleMarker);
                this._arrPolylines[lineNr].circleMarkers.map (function (item, index) {
                    item.cntCircle = index;
                });
                this._arrPolylines[lineNr].circleCoords.splice (arrowNr+1, 0, e.latlng);
                var lineCoords = this._arrPolylines[lineNr].polylinePath.getLatLngs(); // get Coords of each Point of the current Polyline
                var arc1 = this._polylineArc (this._arrPolylines[lineNr].circleCoords[arrowNr], e.latlng);
                arc1.pop();
                var arc2 = this._polylineArc (e.latlng, this._arrPolylines[lineNr].circleCoords[arrowNr+2]);
                Array.prototype.splice.apply (lineCoords, [(arrowNr)*(this._arcpoints-1), this._arcpoints].concat (arc1, arc2));
                this._arrPolylines[lineNr].polylinePath.setLatLngs (lineCoords);
                var arrowMarker = this._drawArrow (arc1);
                this._arrPolylines[lineNr].arrowMarkers[arrowNr] = arrowMarker;
                arrowMarker = this._drawArrow (arc2);
                this._arrPolylines[lineNr].arrowMarkers.splice(arrowNr+1,0,arrowMarker);
                this._arrPolylines[lineNr].arrowMarkers.map (function (item, index) {
                    item.cntLine = lineNr;
                    item.cntArrow = index;
                });
                this._tooltipNew = L.marker (e.latlng, {
                    icon: L.divIcon({
                        className: 'polyline-measure-tooltip',
                        iconAnchor: [-4, -4]
                    }),
                    interactive: false
                });
                this._tooltipNew.addTo(this._layerPaint);
                this._arrPolylines[lineNr].tooltips.splice (arrowNr+1, 0, this._tooltipNew);
                var totalDistance = 0;
                this._arrPolylines[lineNr].tooltips.map (function (item, index) {
                    if (index >= 1) {
                        var distance = this._arrPolylines[lineNr].circleCoords[index-1].distanceTo (this._arrPolylines[lineNr].circleCoords[index]);
                        var lastCircleCoords = this._arrPolylines[lineNr].circleCoords[index - 1];
                        var mouseCoords = this._arrPolylines[lineNr].circleCoords[index];
                        totalDistance += distance;
                        var prevTooltip = this._arrPolylines[lineNr].tooltips[index-1]
                        this._updateTooltip (item, prevTooltip, totalDistance, distance, lastCircleCoords, mouseCoords);
                    }
                }.bind(this));
                this._map.fire('polylinemeasure:insert', e);
                this._map.fire('polylinemeasure:change', this._arrPolylines[this._lineNr]);
            }
        },

        _dragCircleMouseup: function () {
            // bind new popup-tooltip to the last CircleMArker if dragging finished
            if ((this._circleNr === 0) || (this._circleNr === this._arrPolylines[this._lineNr].circleCoords.length-1)) {
               this._e1.target.bindTooltip (this.options.tooltipTextMove + this.options.tooltipTextDelete + this.options.tooltipTextResume, {direction:'top', opacity:0.7, className:'polyline-measure-popupTooltip'});
            } else {
               this._e1.target.bindTooltip (this.options.tooltipTextMove + this.options.tooltipTextDelete, {direction:'top', opacity:0.7, className:'polyline-measure-popupTooltip'});
            }
            this._resetPathVariables();
            this._map.off ('mousemove', this._dragCircleMousemove, this);
            this._map.dragging.enable();
            this._map.on ('mousemove', this._mouseMove, this);
            this._map.off ('mouseup', this._dragCircleMouseup, this);
            this._map.fire('polylinemeasure:move', this._e1);
            this._map.fire('polylinemeasure:change', this._arrPolylines[this._lineNr]);
        },

        _dragCircleMousemove: function (e2) {
            var mouseNewLat = e2.latlng.lat;
            var mouseNewLng = e2.latlng.lng;
            var latDifference = mouseNewLat - this._mouseStartingLat;
            var lngDifference = mouseNewLng - this._mouseStartingLng;
            var currentCircleCoords = L.latLng (this._circleStartingLat + latDifference, this._circleStartingLng + lngDifference);
            var arcpoints = this._arcpoints;
            var lineNr = this._e1.target.cntLine;
            this._lineNr = lineNr;
            var circleNr = this._e1.target.cntCircle;
            this._circleNr = circleNr;
            this._e1.target.setLatLng (currentCircleCoords);
            this._e1.target.unbindTooltip();    // unbind popup-tooltip cause otherwise it would be annoying during dragging, or popup instantly again if it's just closed
            this._arrPolylines[lineNr].circleCoords[circleNr] = currentCircleCoords;
            var lineCoords = this._arrPolylines[lineNr].polylinePath.getLatLngs(); // get Coords of each Point of the current Polyline
            if (circleNr >= 1) {   // redraw previous arc just if circle is not starting circle of polyline
                var newLineSegment1 = this._polylineArc(this._arrPolylines[lineNr].circleCoords[circleNr-1], currentCircleCoords);
                // the next line's syntax has to be used since Internet Explorer doesn't know new spread operator (...) for inserting the individual elements of an array as 3rd argument of the splice method; Otherwise we could write: lineCoords.splice (circleNr*(arcpoints-1), arcpoints, ...newLineSegment1);
                Array.prototype.splice.apply (lineCoords, [(circleNr-1)*(arcpoints-1), arcpoints].concat (newLineSegment1));
                var arrowMarker = this._drawArrow (newLineSegment1);
                arrowMarker.cntLine = lineNr;
                arrowMarker.cntArrow = circleNr-1;
                this._arrPolylines[lineNr].arrowMarkers [circleNr-1].removeFrom (this._layerPaint);
                this._arrPolylines[lineNr].arrowMarkers [circleNr-1] = arrowMarker;
            }
            if (circleNr < this._arrPolylines[lineNr].circleCoords.length-1) {   // redraw following arc just if circle is not end circle of polyline
                var newLineSegment2 = this._polylineArc (currentCircleCoords, this._arrPolylines[lineNr].circleCoords[circleNr+1]);
                Array.prototype.splice.apply (lineCoords, [circleNr*(arcpoints-1), arcpoints].concat (newLineSegment2));
                arrowMarker = this._drawArrow (newLineSegment2);
                arrowMarker.cntLine = lineNr;
                arrowMarker.cntArrow = circleNr;
                this._arrPolylines[lineNr].arrowMarkers [circleNr].removeFrom (this._layerPaint);
                this._arrPolylines[lineNr].arrowMarkers [circleNr] = arrowMarker;
            }
            this._arrPolylines[lineNr].polylinePath.setLatLngs (lineCoords);
            if (circleNr >= 0) {     // just update tooltip position if moved circle is 2nd, 3rd, 4th etc. circle of a polyline
                    this._arrPolylines[lineNr].tooltips[circleNr].setLatLng (currentCircleCoords);
            }
            var totalDistance = 0;
            // update tooltip texts of each tooltip
            this._arrPolylines[lineNr].tooltips.map (function (item, index) {
                if (index >= 1) {
                    var distance = this._arrPolylines[lineNr].circleCoords[index-1].distanceTo (this._arrPolylines[lineNr].circleCoords[index]);
                    var lastCircleCoords = this._arrPolylines[lineNr].circleCoords[index - 1];
                    var mouseCoords = this._arrPolylines[lineNr].circleCoords[index];
                    totalDistance += distance;
                    this._arrPolylines[lineNr].distance = totalDistance;
                    var prevTooltip = this._arrPolylines[lineNr].tooltips[index-1]
                    this._updateTooltip (item, prevTooltip, totalDistance, distance, lastCircleCoords, mouseCoords);
                }
            }.bind(this));
            this._map.on ('mouseup', this._dragCircleMouseup, this);
        },

        _resumeFirstpointMousemove: function (e) {
            var lineNr = this._lineNr;
            this._map.on ('click', this._resumeFirstpointClick, this);  // necassary for _dragCircle. If switched on already within _dragCircle an unwanted click is fired at the end of the drag.
            var mouseCoords = e.latlng;
            this._rubberlinePath2.setLatLngs (this._polylineArc (mouseCoords, currentCircleCoords));
            this._tooltipNew.setLatLng (mouseCoords);
            var totalDistance = 0;
            var distance = mouseCoords.distanceTo (this._arrPolylines[lineNr].circleCoords[0]);
            var lastCircleCoords = mouseCoords;
            var currentCoords = this._arrPolylines[lineNr].circleCoords[0];
            totalDistance += distance;
            var prevTooltip = this._tooltipNew;
            var currentTooltip = this._arrPolylines[lineNr].tooltips[0]
            this._updateTooltip (currentTooltip, prevTooltip, totalDistance, distance, lastCircleCoords, currentCoords);
            this._arrPolylines[lineNr].tooltips.map (function (item, index) {
                if (index >= 1) {
                    var distance = this._arrPolylines[lineNr].circleCoords[index-1].distanceTo (this._arrPolylines[lineNr].circleCoords[index]);
                    var lastCircleCoords = this._arrPolylines[lineNr].circleCoords[index - 1];
                    var mouseCoords = this._arrPolylines[lineNr].circleCoords[index];
                    totalDistance += distance;
                    var prevTooltip = this._arrPolylines[lineNr].tooltips[index-1]
                    this._updateTooltip (item, prevTooltip, totalDistance, distance, lastCircleCoords, mouseCoords);
                }
            }.bind (this));
        },

        _resumeFirstpointClick: function (e) {
            var lineNr = this._lineNr;
            this._resumeFirstpointFlag = false;
            this._map.off ('mousemove', this._resumeFirstpointMousemove, this);
            this._map.off ('click', this._resumeFirstpointClick, this);
            this._layerPaint.removeLayer (this._rubberlinePath2);
            this._arrPolylines[lineNr].circleMarkers [0].setStyle (this.options.intermedCircle);
            this._arrPolylines[lineNr].circleMarkers [0].unbindTooltip();
            this._arrPolylines[lineNr].circleMarkers [0].bindTooltip (this.options.tooltipTextMove + this.options.tooltipTextDelete, {direction:'top', opacity:0.7, className:'polyline-measure-popupTooltip'});
            var newCircleMarker = new L.CircleMarker (e.latlng, this.options.startCircle).addTo(this._layerPaint);
            newCircleMarker.cntLine = lineNr;
            newCircleMarker.cntCircle = 0;
            newCircleMarker.on ('mousedown', this._dragCircle, this);
            newCircleMarker.bindTooltip (this.options.tooltipTextMove + this.options.tooltipTextDelete + this.options.tooltipTextResume, {direction:'top', opacity:0.7, className:'polyline-measure-popupTooltip'});
            this._arrPolylines[lineNr].circleMarkers.unshift(newCircleMarker);
            this._arrPolylines[lineNr].circleMarkers.map (function (item, index) {
                item.cntCircle = index;
            });
            this._arrPolylines[lineNr].circleCoords.unshift(e.latlng);
            var arc = this._polylineArc (e.latlng, currentCircleCoords);
            var arrowMarker = this._drawArrow (arc);
            this._arrPolylines[lineNr].arrowMarkers.unshift(arrowMarker);
            this._arrPolylines[lineNr].arrowMarkers.map (function (item, index) {
                item.cntLine = lineNr;
                item.cntArrow = index;
            });
            arc.pop();  // remove last coordinate of arc, cause it's already part of the next arc.
            this._arrPolylines[lineNr].polylinePath.setLatLngs (arc.concat(this._arrPolylines[lineNr].polylinePath.getLatLngs()));
            this._arrPolylines[lineNr].tooltips.unshift(this._tooltipNew);
            this._map.on ('mousemove', this._mouseMove, this);
        },


        // not just used for dragging Cirles but also for deleting circles and resuming line at its starting point.
        _dragCircle: function (e1) {
            var arcpoints = this._arcpoints;
            if (e1.originalEvent.ctrlKey || e1.originalEvent.metaKey) {   // if user wants to resume drawing a line. metaKey for Mac
                this._map.off ('click', this._mouseClick, this); // to avoid unwanted creation of a new line if CTRL-clicked onto a point
                // if user wants resume the line at its starting point
                if (e1.target.cntCircle === 0) {
                    this._resumeFirstpointFlag = true;
                    this._lineNr = e1.target.cntLine;
                    var lineNr = this._lineNr;
                    this._circleNr = e1.target.cntCircle;
                    currentCircleCoords = e1.latlng;
                    this._arrPolylines[lineNr].circleMarkers [0].setStyle (this.options.currentCircle);
                    this._rubberlinePath2 = L.polyline ([], {
                        // Style of temporary, rubberline while moving the mouse
                        color: this.options.tempLine.color,
                        weight: this.options.tempLine.weight,
                        interactive: false,
                        dashArray: '8,8'
                    }).addTo(this._layerPaint).bringToBack();
                    this._tooltipNew = L.marker (currentCircleCoords, {
                        icon: L.divIcon({
                            className: 'polyline-measure-tooltip',
                            iconAnchor: [-4, -4]
                        }),
                        interactive: false
                    });
                    this._tooltipNew.addTo(this._layerPaint);
                    var text='';
                    if (this.options.showBearings === true) {
                        text = text + this.options.bearingTextIn+':---°<br>'+this.options.bearingTextOut+':---°';
                    }
                    text = text + '<div class="polyline-measure-tooltip-difference">+' + '0</div>';
                    text = text + '<div class="polyline-measure-tooltip-total">' + '0</div>';
                    this._tooltipNew._icon.innerHTML = text;
                    this._map.off ('mousemove', this._mouseMove, this);
                    this._map.on ('mousemove', this._resumeFirstpointMousemove, this);
                }
                return;
            }

            // if user wants to delete a circle
            if (e1.originalEvent.shiftKey) {    // it's not possible to use "ALT-Key" instead, cause this won't work in some Linux distributions (there it's the default hotkey for moving windows)
                this._lineNr = e1.target.cntLine;
                var lineNr = this._lineNr;
                this._circleNr = e1.target.cntCircle;
                var circleNr = this._circleNr;

                // if there is a polyline with this number in finished ones
                if (this._arrPolylines[lineNr]) {
                    if (this._arrPolylines[lineNr].circleMarkers.length === 2) {    // if there are just 2 remaining points, delete all these points and the remaining line, since there should not stay a lonely point the map
                      this._layerPaint.removeLayer (this._arrPolylines[lineNr].circleMarkers [1]);
                      this._layerPaint.removeLayer (this._arrPolylines[lineNr].tooltips [1]);
                      this._layerPaint.removeLayer (this._arrPolylines[lineNr].circleMarkers [0]);
                      this._layerPaint.removeLayer (this._arrPolylines[lineNr].tooltips [0]);
                      this._layerPaint.removeLayer (this._arrPolylines[lineNr].arrowMarkers [0]);
                      this._layerPaint.removeLayer (this._arrPolylines[lineNr].polylinePath);
                      this._map.fire('polylinemeasure:remove', e1);
                      this._map.fire('polylinemeasure:change', this._arrPolylines[this._lineNr]);
                      return;
                    }

                    this._arrPolylines[lineNr].circleCoords.splice(circleNr,1);
                    this._arrPolylines[lineNr].circleMarkers [circleNr].removeFrom (this._layerPaint);
                    this._arrPolylines[lineNr].circleMarkers.splice(circleNr,1);
                    this._arrPolylines[lineNr].circleMarkers.map (function (item, index) {
                        item.cntCircle = index;
                    });
                    var lineCoords = this._arrPolylines[lineNr].polylinePath.getLatLngs();
                    this._arrPolylines[lineNr].tooltips [circleNr].removeFrom (this._layerPaint);
                    this._arrPolylines[lineNr].tooltips.splice(circleNr,1);

                    // if the last Circle in polyline is being removed (in the code above, so length will be equal 0)
                    if(!this._arrPolylines[lineNr].circleMarkers.length) {
                        this._arrPolylines.splice(lineNr, 1);
                        // when you delete the line in the middle of array, other lines indexes change, so you need to update line number of markers and circles
                        this._arrPolylines.forEach(function(line, index) {
                            line.circleMarkers.map(function (item) {
                                item.cntLine = index;
                            });
                            line.arrowMarkers.map(function (item) {
                                item.cntLine = index;
                            });
                        });

                        return;
                    }
                    // if first Circle is being removed
                    if (circleNr === 0) {
                        this._arrPolylines[lineNr].circleMarkers [0].setStyle (this.options.startCircle);
                        lineCoords.splice (0, arcpoints-1);
                        this._arrPolylines[lineNr].circleMarkers [0].bindTooltip (this.options.tooltipTextMove + this.options.tooltipTextDelete + this.options.tooltipTextResume, {direction:'top', opacity:0.7, className:'polyline-measure-popupTooltip'});
                        this._arrPolylines[lineNr].arrowMarkers [circleNr].removeFrom (this._layerPaint);
                        this._arrPolylines[lineNr].arrowMarkers.splice(0,1);
                        var text='';
                        if (this.options.showBearings === true) {
                            text = this.options.bearingTextIn+':---°<br>'+this.options.bearingTextOut+':---°';
                        }
                        text = text + '<div class="polyline-measure-tooltip-difference">+' + '0</div>';
                        text = text + '<div class="polyline-measure-tooltip-total">' + '0</div>';
                        this._arrPolylines[lineNr].tooltips [0]._icon.innerHTML = text;
                        // if last Circle is being removed
                    } else if (circleNr === this._arrPolylines[lineNr].circleCoords.length) {
                        this._arrPolylines[lineNr].circleMarkers [circleNr-1].on ('click', this._resumePolylinePath, this);
                        this._arrPolylines[lineNr].circleMarkers [circleNr-1].bindTooltip (this.options.tooltipTextMove + this.options.tooltipTextDelete + this.options.tooltipTextResume, {direction:'top', opacity:0.7, className:'polyline-measure-popupTooltip'});
                        this._arrPolylines[lineNr].circleMarkers.slice(-1)[0].setStyle (this.options.endCircle);  // get last element of the array
                        this._arrPolylines[lineNr].tooltips.slice(-1)[0]._icon.classList.add('polyline-measure-tooltip-end');
                        lineCoords.splice (-(arcpoints-1), arcpoints-1);
                        this._arrPolylines[lineNr].arrowMarkers [circleNr-1].removeFrom (this._layerPaint);
                        this._arrPolylines[lineNr].arrowMarkers.splice(-1,1);
                        // if intermediate Circle is being removed
                    } else {
                        var newLineSegment = this._polylineArc (this._arrPolylines[lineNr].circleCoords[circleNr-1], this._arrPolylines[lineNr].circleCoords[circleNr]);
                        Array.prototype.splice.apply (lineCoords, [(circleNr-1)*(arcpoints-1), (2*arcpoints-1)].concat (newLineSegment));
                        this._arrPolylines[lineNr].arrowMarkers [circleNr-1].removeFrom (this._layerPaint);
                        this._arrPolylines[lineNr].arrowMarkers [circleNr].removeFrom (this._layerPaint);
                        var arrowMarker = this._drawArrow (newLineSegment);
                        this._arrPolylines[lineNr].arrowMarkers.splice(circleNr-1,2,arrowMarker);
                    }
                    this._arrPolylines[lineNr].polylinePath.setLatLngs (lineCoords);
                    this._arrPolylines[lineNr].arrowMarkers.map (function (item, index) {
                        item.cntLine = lineNr;
                        item.cntArrow = index;
                    });
                    var totalDistance = 0;
                    this._arrPolylines[lineNr].tooltips.map (function (item, index) {
                        if (index >= 1) {
                            var distance = this._arrPolylines[lineNr].circleCoords[index-1].distanceTo (this._arrPolylines[lineNr].circleCoords[index]);
                            var lastCircleCoords = this._arrPolylines[lineNr].circleCoords[index - 1];
                            var mouseCoords = this._arrPolylines[lineNr].circleCoords[index];
                            totalDistance += distance;
                            this._arrPolylines[lineNr].distance = totalDistance;
                            var prevTooltip = this._arrPolylines[lineNr].tooltips[index-1];
                            this._updateTooltip (item, prevTooltip, totalDistance, distance, lastCircleCoords, mouseCoords);
                        }
                    }.bind (this));
                // if this is the first line and it's not finished yet
                } else {
                    // when you're drawing and deleting point you need to take it into account by decreasing _cntCircle
                  this._cntCircle--;
                  // if the last Circle in polyline is being removed
                  if(this._currentLine.circleMarkers.length === 1) {
                      this._currentLine.finalize();
                      return;
                  }

                    this._currentLine.circleCoords.splice(circleNr,1);
                    this._currentLine.circleMarkers [circleNr].removeFrom (this._layerPaint);
                    this._currentLine.circleMarkers.splice(circleNr,1);
                    this._currentLine.circleMarkers.map (function (item, index) {
                        item.cntCircle = index;
                    });
                    lineCoords = this._currentLine.polylinePath.getLatLngs();
                    this._currentLine.tooltips [circleNr].removeFrom (this._layerPaint);
                    this._currentLine.tooltips.splice(circleNr,1);

                    // if first Circle is being removed
                    if (circleNr === 0) {
                    if(this._currentLine.circleMarkers.length === 1) {
                        this._currentLine.circleMarkers [0].setStyle (this.options.currentCircle);
                    } else {
                        this._currentLine.circleMarkers [0].setStyle (this.options.startCircle);
                    }
                        lineCoords.splice (0, arcpoints-1);
                        this._currentLine.circleMarkers [0].bindTooltip (this.options.tooltipTextMove + this.options.tooltipTextDelete + this.options.tooltipTextResume, {direction:'top', opacity:0.7, className:'polyline-measure-popupTooltip'});
                        this._currentLine.arrowMarkers [circleNr].removeFrom (this._layerPaint);
                        this._currentLine.arrowMarkers.splice(0,1);
                        var text='';
                        if (this.options.showBearings === true) {
                            text = this.options.bearingTextIn+':---°<br>'+this.options.bearingTextOut+':---°';
                        }
                        text = text + '<div class="polyline-measure-tooltip-difference">+' + '0</div>';
                        text = text + '<div class="polyline-measure-tooltip-total">' + '0</div>';
                        this._currentLine.tooltips [0]._icon.innerHTML = text;
                        // if last Circle is being removed
                    } else if (circleNr === this._currentLine.circleCoords.length) {
                        this._currentLine.circleMarkers [circleNr-1].on ('click', this._resumePolylinePath, this);
                        this._currentLine.circleMarkers [circleNr-1].bindTooltip (this.options.tooltipTextMove + this.options.tooltipTextDelete + this.options.tooltipTextResume, {direction:'top', opacity:0.7, className:'polyline-measure-popupTooltip'});
                        this._currentLine.circleMarkers.slice(-1)[0].setStyle (this.options.currentCircle);  // get last element of the array
                        this._currentLine.tooltips.slice(-1)[0]._icon.classList.add('polyline-measure-tooltip-end');
                        lineCoords.splice (-(arcpoints-1), arcpoints-1);
                        this._currentLine.arrowMarkers [circleNr-1].removeFrom (this._layerPaint);
                        this._currentLine.arrowMarkers.splice(-1,1);
                        // if intermediate Circle is being removed
                    } else {
                        newLineSegment = this._polylineArc (this._currentLine.circleCoords[circleNr-1], this._currentLine.circleCoords[circleNr]);
                        Array.prototype.splice.apply (lineCoords, [(circleNr-1)*(arcpoints-1), (2*arcpoints-1)].concat (newLineSegment));
                        this._currentLine.arrowMarkers [circleNr-1].removeFrom (this._layerPaint);
                        this._currentLine.arrowMarkers [circleNr].removeFrom (this._layerPaint);
                        arrowMarker = this._drawArrow (newLineSegment);
                        this._currentLine.arrowMarkers.splice(circleNr-1,2,arrowMarker);
                    }
                    this._currentLine.polylinePath.setLatLngs (lineCoords);
                    this._currentLine.arrowMarkers.map (function (item, index) {
                        item.cntLine = lineNr;
                        item.cntArrow = index;
                    });
                    var totalDistanceUnfinishedLine = 0;
                    this._currentLine.tooltips.map (function (item, index, arr) {
                        if (index >= 1) {
                      var distance, mouseCoords;
                      var prevTooltip = this._currentLine.tooltips[index-1];
                      var lastCircleCoords = this._currentLine.circleCoords[index - 1];
                      if(index === arr.length - 1) {
                          distance = this._currentLine.circleCoords[index-1].distanceTo (e1.latlng);
                          mouseCoords = e1.latlng;
                          // if this is the last Circle (mouse cursor) then don't sum the distance, but update tooltip like it was summed
                          this._updateTooltip (item, prevTooltip, totalDistanceUnfinishedLine + distance, distance, lastCircleCoords, mouseCoords);
                      } else {
                          distance = this._currentLine.circleCoords[index-1].distanceTo (this._currentLine.circleCoords[index]);
                          mouseCoords = this._currentLine.circleCoords[index];
                          // if this is not the last Circle (mouse cursor) then sum the distance
                          totalDistanceUnfinishedLine += distance;
                          this._updateTooltip (item, prevTooltip, totalDistanceUnfinishedLine, distance, lastCircleCoords, mouseCoords);
                      }
                        }
                    }.bind (this));

                    // update _currentLine distance after point deletion
                    this._currentLine.distance = totalDistanceUnfinishedLine;
                }

                this._map.fire('polylinemeasure:remove', e1);
                this._map.fire('polylinemeasure:change', this._arrPolylines[this._lineNr]);
                return;
            }
            this._e1 = e1;
            if ((this._measuring) && (this._cntCircle === 0)) {    // just execute drag-function if Measuring tool is active but no line is being drawn at the moment.
                this._map.dragging.disable();  // turn of moving of the map during drag of a circle
                this._map.off ('mousemove', this._mouseMove, this);
                this._map.off ('click', this._mouseClick, this);
                this._mouseStartingLat = e1.latlng.lat;
                this._mouseStartingLng = e1.latlng.lng;
                this._circleStartingLat = e1.target._latlng.lat;
                this._circleStartingLng = e1.target._latlng.lng;
                this._map.on ('mousemove', this._dragCircleMousemove, this);
            }
        },

        /**
         * Takes in a dataset and programatically draws the polylines and measurements to the map
         * Dataset must be in the form of an array of LatLng[], which allows for multiple discontinuous
         * polylines to be seeded
         * @param {L.LatLng[][]} polylinesArray | Array of array of points
         */
        seed: function(polylinesArray){
            // Hijack user actions to manually draw polylines
            polylinesArray.forEach((polyline) => {
                // toggle draw state on:
                this._toggleMeasure();
                // start line with first point of each polyline
                this._startLine(polyline[0]);
                // add subsequent points:
                polyline.forEach((point, ind) => {
                    const latLng = L.latLng(point);
                    this._mouseMove({ latLng });
                    this._currentLine.addPoint(latLng);
                    // on last point,
                    if (ind === polyline.length - 1) {
                        this._finishPolylinePath();
                        this._toggleMeasure();
                    }
                });
            });
        }
    });

//======================================================================================

    L.Map.mergeOptions({
        PolylineMeasureControl: false
    });

    L.Map.addInitHook(function () {
        if (this.options.polylineMeasureControl) {
            this.PMControl = new L.Control.PolylineMeasure();
            this.addControl(this.PMControl);
        }
    });

    L.control.polylineMeasure = function (options) {
        return new L.Control.PolylineMeasure (options);
    };

    return L.Control.PolylineMeasure;
    // to allow
    // import PolylineMeasure from 'leaflet.polylinemeasure';
    // const measureControl = new PolylineMeasure();
    // together with
    // import 'leaflet.polylinemeasure';
    // const measureControl = new L.Control.PolylineMeasure();

}));


//Measure Control Start
L.control.scale ({maxWidth:240, metric:true, imperial:false, position: 'bottomleft'}).addTo (map);
            let polylineMeasure = L.control.polylineMeasure ({position:'topleft', unit:'kilometres', showBearings:true, clearMeasurementsOnStop: false, showClearControl: true, showUnitControl: true})
            polylineMeasure.addTo (map);

            function debugevent(e) { console.debug(e.type, e, polylineMeasure._currentLine) }

            map.on('polylinemeasure:toggle', debugevent);
            map.on('polylinemeasure:start', debugevent);
            map.on('polylinemeasure:resume', debugevent);
            map.on('polylinemeasure:finish', debugevent);
            map.on('polylinemeasure:change', debugevent);
            map.on('polylinemeasure:clear', debugevent);
            map.on('polylinemeasure:add', debugevent);
            map.on('polylinemeasure:insert', debugevent);
            map.on('polylinemeasure:move', debugevent);
            map.on('polylinemeasure:remove', debugevent);




//GPS*******************
(function (factory) {
    if(typeof define === 'function' && define.amd) {
    //AMD
        define(['leaflet'], factory);
    } else if(typeof module !== 'undefined') {
    // Node/CommonJS
        module.exports = factory(require('leaflet'));
    } else {
    // Browser globals
        if(typeof window.L === 'undefined')
            throw 'Leaflet must be loaded first';
        factory(window.L);
    }
})(function (L) {

L.Control.Gps = L.Control.extend({

    includes: L.version[0] =='1' ? L.Evented.prototype : L.Mixin.Events,
    //
    //Managed Events:
    //  Event           Data passed         Description
    //
    //  gps:located     {marker,latlng}     fired after gps marker is located
    //  gps:disabled    {marker}            fired after gps is disabled
    //  gps:error       {message}           fired after gps error
    //
    //Methods exposed:
    //  Method          Description
    //
    //  getLocation     return Latlng and marker of current position
    //  activate        active tracking on runtime
    //  deactivate      deactive tracking on runtime
    //
    options: {
        autoActive: false,      //activate control at startup
        autoCenter: false,      //move map when gps location change
        autoFollow: true,       //move map continuously
        maxZoom: null,          //max zoom for autoCenter
        textErr: '',            //error message on alert notification
        callErr: null,          //function that run on gps error activating
        title: 'Center map on your location',
        marker: null,           //L.Marker used for location, default use a L.CircleMarker
        style: {                //default L.CircleMarker styles
            radius: 5,
            weight: 2,
            color: '#c20',
            opacity: 1,
            fillColor: '#f23',
            fillOpacity: 1
        },
        //accuracy: true,       //show accuracy Circle
        position: 'topleft',
        transform: function(latlng) { return latlng },
        //TODO add gpsLayer
        //TODO timeout autoCenter
    },

    initialize: function(options) {
        if(options && options.style)
            options.style = L.Util.extend({}, this.options.style, options.style);
        L.Util.setOptions(this, options);
        this._errorFunc = this.options.callErr || this.showAlert;
        this._isActive = false;
        this._isLoading = false;
        this._currentLocation = null;   //store last location
    },

    onAdd: function (map) {

        this._map = map;

        var container = L.DomUtil.create('div', 'leaflet-control-gps');

        this._button = L.DomUtil.create('a', 'gps-button', container);
        this._button.href = '#';
        this._button.title = this.options.title;

        L.DomEvent
            .on(this._button, 'dblclick', L.DomEvent.stop, this)
            .on(this._button, 'click', L.DomEvent.stop, this)
            .on(this._button, 'click', this._switchGps, this);

        this._alert = L.DomUtil.create('div', 'gps-alert', container);
        this._alert.style.display = 'none';

        this._gpsMarker = this.options.marker ? this.options.marker : new L.CircleMarker([0,0], this.options.style);
        //if(this.options.accuracy)
        //  this._accuracyCircle = new L.Circle([0,0], this.options.style);

        if(this.options.autoFollow) {
            this._map.on('locationfound', this._drawGps, this);
        }
        else {
            this._map.once('locationfound', this._drawGps, this);
        }

        this._map.on('locationerror', this._errorGps, this);

        if(this.options.autoActive)
            this.activate();

        return container;
    },

    onRemove: function(map) {
        this.deactivate();

        map.off('locationfound', this._drawGps, this)
           .off('locationerror', this._errorGps, this);
    },

    _switchGps: function() {
        if(this._isActive || this._isLoading)
            this.deactivate();
        else
            this.activate();
    },

    getLocation: function() {   //get last location
        return this._currentLocation;
    },

    activate: function() {

        this._isActive = true;
        this._isLoading = true;
        this._map.addLayer( this._gpsMarker );

        L.DomUtil.addClass(this._button, 'loading');

        this._map.once('locationfound', function(e) {

            L.DomUtil.removeClass(this._button, 'loading');
            L.DomUtil.removeClass(this._button, 'disabled');
            L.DomUtil.addClass(this._button, 'active');

            this._isLoading = false;

            if(this.options.autoCenter)
                this._map.setView(e.latlng, this.options.maxZoom || this._map.getZoom());

        }, this);

        this._map.locate({
            enableHighAccuracy: false,
            watch: true,
            setView: false,//this.options.autoCenter,
            //maxZoom: this.options.maxZoom || this._map.getZoom()
        });
    },

    deactivate: function() {

        this._isActive = false;
        this._isLoading = false;

        L.DomUtil.removeClass(this._button, 'active');
        L.DomUtil.removeClass(this._button, 'loading');

        if(this._map) {
            this._map.stopLocate();
            this._map.removeLayer( this._gpsMarker );
        }

        //this._gpsMarker.setLatLng([-90,0]);  //move to antarctica!
        //TODO make method .hide() using _icon.style.display = 'none'
        this.fire('gps:disabled', {marker: this._gpsMarker});
    },

    _drawGps: function(e) {

        var self = this;

        //TODO use e.accuracy for gps circle radius/color
        this._currentLocation = this.options.transform(e.latlng);

        this._gpsMarker.setLatLng(this._currentLocation);

        if(this.options.autoFollow) {
            this._map.on('locationfound', this._drawGps, this);
        }
        else {
            this._map.once('locationfound', this._drawGps, this);
        }

        this._map.on('locationerror', this._errorGps, this);

        if(this.options.autoActive)
            this.activate();

    //      if(this._gpsMarker.accuracyCircle)
    //          this._gpsMarker.accuracyCircle.setRadius((e.accuracy / 2).toFixed(0));
    },

    _errorGps: function(e) {
        this.fire('gps:error', e);

        this.deactivate();

        L.DomUtil.addClass(this._button, 'disabled');

        this._errorFunc.call(this, this.options.textErr || e.message);
    },

    /*  _updateAccuracy: function (event) {
            var newZoom = this._map.getZoom(),
                scale = this._map.options.crs.scale(newZoom);
            this._gpsMarker.setRadius(this.options.style.radius * scale);
            this._gpsMarker.redraw();
        },
    */
    showAlert: function(text) {
        this._alert.style.display = 'block';
        this._alert.innerHTML = text;
        var that = this;
        clearTimeout(this.timerAlert);
        this.timerAlert = setTimeout(function() {
            that._alert.style.display = 'none';
        }, 5000);
    }
});

L.Map.addInitHook(function () {
    if (this.options.gpsControl) {
        this.gpsControl = L.control.gps(this.options.gpsControl);
        this.addControl(this.gpsControl);
    }
});

L.control.gps = function (options) {
    return new L.Control.Gps(options);
};

    return L.Control.Gps;
});


//circleWithText([44.7, -79.38], '45', {radius: 20, weight: 2, color: 'green'}).addTo(map);


//creates search box and places at the top of the map for user searches provided by OpenStreetMap, zooms in to search entry upon selection
 const provider = new window.GeoSearch.OpenStreetMapProvider();
    const search = new GeoSearch.GeoSearchControl({
      provider: provider,
      //style: 'bar',
      //updateMap: true,
      //keepResult: true,
      showMarker: true,
      autoClose: true,
      showPopup: true,
       popupFormat: ({ query, result }) => `
       ${result.label}<br />
      LatLong: ${result.y.toFixed(5)}, ${result.x.toFixed(5)}
  `,

      marker: {
        icon: new L.Icon.Default(),
        draggable: false,
  },
    

    //popupFormat: ({ result }) => [result.x.toString(), // optional: function    - default returns result label,
    //resultFormat: ({ result }) => result.label, // optional: function    - default returns result label
    keepResult: true, // optional: true|false  - default false
    style: 'button'

   }).addTo(map);


//Basemap switcher**************
L.Control.basemapsSwitcher = L.Control.extend({
    options: {
        position: 'topright',
        maxZoom: 18,
    },

    initialize: function(layers, options){
        L.Util.setOptions(this, options);
        this.layers = layers
    },

    onAdd: function (map){
        const container = this.container = L.DomUtil.create('div', 'leaflet-control-basemapsSwitcher');

        this._createItems();
        this._collapse();

        container.addEventListener('mouseover', () => {
            this._expand();
        })

        container.addEventListener('mouseout', () => {
            this._collapse();
        })

        return container;
    },

    _createItems() {
        this.layers.forEach( (obj, index) => {

            obj.id = index

            const imgContainer = L.DomUtil.create('div', 'basemapImg');
            const img = L.DomUtil.create('div');
            const name = L.DomUtil.create('div', 'name');
            const check = L.DomUtil.create('div', 'check');
            name.innerHTML = obj.name

            if(obj.layer?._map){
                this.activeMap = obj
                check.classList.add('activeMap');
            }
            
            img.style.backgroundImage = `url(${obj.icon})`;
            imgContainer.append(img)
            img.append(check)
            img.append(name)
            
            imgContainer.addEventListener('click', () =>{

                this._removeLayers(obj.layer);
                
                if(!obj.layer?._map){
                    obj.layer.addTo(this._map);
                    this.activeMap = obj;
                    this._collapse();

                    check.classList.add('activeMap');
                }

            })

            this.container.append(imgContainer)

        })
    },

    _removeLayers(layer){

        this.layers.forEach( (obj) =>{
            if(obj.layer._leaflet_id !== layer._leaflet_id && obj.layer?._map) {
                this._map.removeLayer(obj.layer);
            }
        })
    },

    _collapse(){

        this.container.childNodes.forEach( (child, index) => {

            if(index !== this.activeMap.id){
                child.classList.add('hidden')
                let check = child.querySelector('.check')
                check.classList.remove('activeMap')
            }
        })

    },

    _expand(){

        this.container.childNodes.forEach( (child) => {
            child.classList.remove('hidden')
        })
    }

})

L.basemapsSwitcher = function(layers, options){
    return new L.Control.basemapsSwitcher(layers, options);  
}

//creates home zoom control box, with large home icon and larger zoom+/- icons from fontawesome, home button returns to full out zoom and mapcenter
    L.Control.zoomHome = L.Control.extend({
    options: {
        position: 'topleft',
        zoomInText: '<i class="fa fa-plus fa-lg"></i>',
        zoomInTitle: 'Zoom in',
        zoomOutText: '<i class="fa fa-minus fa-lg"></i>',
        zoomOutTitle: 'Zoom out',
        zoomHomeText: '<i class="fa fa-home fa-lg" style="line-height:2;"></i>',
        zoomHomeTitle: 'Zoom home'
    },

    onAdd: function (map) {
        var controlName = 'gin-control-zoom',
            container = L.DomUtil.create('div', controlName + ' leaflet-bar'),
            options = this.options;

        this._zoomInButton = this._createButton(options.zoomInText, options.zoomInTitle,
        controlName + '-in', container, this._zoomIn);
        this._zoomHomeButton = this._createButton(options.zoomHomeText, options.zoomHomeTitle,
        controlName + '-home', container, this._zoomHome);
        this._zoomOutButton = this._createButton(options.zoomOutText, options.zoomOutTitle,
        controlName + '-out', container, this._zoomOut);

        this._updateDisabled();
        map.on('zoomend zoomlevelschange', this._updateDisabled, this);

        return container;
    },

    onRemove: function (map) {
        map.off('zoomend zoomlevelschange', this._updateDisabled, this);
    },

    _zoomIn: function (e) {
        this._map.zoomIn(e.shiftKey ? 3 : 1);
    },

    _zoomOut: function (e) {
        this._map.zoomOut(e.shiftKey ? 3 : 1);
    },

    _zoomHome: function (e) {
        map.setView([lat, lng], zoom);
    },

    _createButton: function (html, title, className, container, fn) {
        var link = L.DomUtil.create('a', className, container);
        link.innerHTML = html;
        link.href = '#';
        link.title = title;

        L.DomEvent.on(link, 'mousedown dblclick', L.DomEvent.stopPropagation)
            .on(link, 'click', L.DomEvent.stop)
            .on(link, 'click', fn, this)
            .on(link, 'click', this._refocusOnMap, this);

        return link;
    },

    _updateDisabled: function () {
        var map = this._map,
            className = 'leaflet-disabled';

        L.DomUtil.removeClass(this._zoomInButton, className);
        L.DomUtil.removeClass(this._zoomOutButton, className);

        if (map._zoom === map.getMinZoom()) {
            L.DomUtil.addClass(this._zoomOutButton, className);
        }
        if (map._zoom === map.getMaxZoom()) {
            L.DomUtil.addClass(this._zoomInButton, className);
        }
    }
});


//*****************


//creates home zoom control box, with large home icon and larger zoom+/- icons from fontawesome, home button returns to full out zoom and mapcenter
    L.Control.zoomHome = L.Control.extend({
    options: {
        position: 'topleft',
        zoomInText: '<i class="fa fa-plus fa-lg"></i>',
        zoomInTitle: 'Zoom in',
        zoomOutText: '<i class="fa fa-minus fa-lg"></i>',
        zoomOutTitle: 'Zoom out',
        zoomHomeText: '<i class="fa fa-home fa-lg" style="line-height:2;"></i>',
        zoomHomeTitle: 'Zoom home'
    },

    onAdd: function (map) {
        var controlName = 'gin-control-zoom',
            container = L.DomUtil.create('div', controlName + ' leaflet-bar'),
            options = this.options;

        this._zoomInButton = this._createButton(options.zoomInText, options.zoomInTitle,
        controlName + '-in', container, this._zoomIn);
        this._zoomHomeButton = this._createButton(options.zoomHomeText, options.zoomHomeTitle,
        controlName + '-home', container, this._zoomHome);
        this._zoomOutButton = this._createButton(options.zoomOutText, options.zoomOutTitle,
        controlName + '-out', container, this._zoomOut);

        this._updateDisabled();
        map.on('zoomend zoomlevelschange', this._updateDisabled, this);

        return container;
    },

    onRemove: function (map) {
        map.off('zoomend zoomlevelschange', this._updateDisabled, this);
    },

    _zoomIn: function (e) {
        this._map.zoomIn(e.shiftKey ? 3 : 1);
    },

    _zoomOut: function (e) {
        this._map.zoomOut(e.shiftKey ? 3 : 1);
    },

    _zoomHome: function (e) {
        map.setView([lat, lng], zoom);
    },

    _createButton: function (html, title, className, container, fn) {
        var link = L.DomUtil.create('a', className, container);
        link.innerHTML = html;
        link.href = '#';
        link.title = title;

        L.DomEvent.on(link, 'mousedown dblclick', L.DomEvent.stopPropagation)
            .on(link, 'click', L.DomEvent.stop)
            .on(link, 'click', fn, this)
            .on(link, 'click', this._refocusOnMap, this);

        return link;
    },

    _updateDisabled: function () {
        var map = this._map,
            className = 'leaflet-disabled';

        L.DomUtil.removeClass(this._zoomInButton, className);
        L.DomUtil.removeClass(this._zoomOutButton, className);

        if (map._zoom === map.getMinZoom()) {
            L.DomUtil.addClass(this._zoomOutButton, className);
        }
        if (map._zoom === map.getMaxZoom()) {
            L.DomUtil.addClass(this._zoomInButton, className);
        }
    }
});

// add the new custom zoom control to the map with home button and larger fontawesome icons for clarity (defaults too small)
var zoomHome = new L.Control.zoomHome();
zoomHome.addTo(map);


//BASEMAP SWITCHER START*****************************
new L.basemapsSwitcher([
    {
    layer: L.tileLayer('https://{s}.basemaps.cartocdn.com/rastertiles/voyager/{z}/{x}/{y}{r}.png', {
        attribution: '<a href="https://www.openstreetmap.org/copyright">OSM</a> | TopSecret'
              //attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
    }), 
    icon: 'https://raw.githubusercontent.com/sean-roelofsen/Hamilton/main/OSMThumbs.png',
    name: 'Mobile'
  },
  
  
    {
    layer: L.tileLayer('https://tile.thunderforest.com/pioneer/{z}/{x}/{y}.png?apikey=5c03259962714d199387f52b55b58e82',{
      attribution: '<a href="https://www.openstreetmap.org/copyright">OSM</a> | TopSecret'
          }).addTo(map), //DEFAULT MAP
    icon: 'https://raw.githubusercontent.com/sean-roelofsen/HP-Abatement/main/Basemap1Carto.png',
    name: 'Vintage'
  },
   
  {
    layer: L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', {
        attribution: '<a href="https://www.openstreetmap.org/copyright">OSM</a> | TopSecret'
             // attribution: 'Map data: &copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors, <a href="http://viewfinderpanoramas.org">SRTM</a> | Map style: &copy; <a href="https://opentopomap.org">OpenTopoMap</a> (<a href="https://creativecommons.org/licenses/by-sa/3.0/">CC-BY-SA</a>)'
    }),
    icon: 'https://raw.githubusercontent.com/sean-roelofsen/HP-Abatement/main/AerialImageryESRIThumb.png',
    name: 'Satellite'
      },

], { position: 'bottomright' }).addTo(map);




var gps = new L.Control.Gps({
        //autoActive:true,
        autoCenter:true
    });//inizialize control

    gps
    .on('gps:located', function(e) {
          e.marker.bindPopup(e.latlng.toString()).openPopup()
        console.log(e.latlng, map.getCenter())
    })
    .on('gps:disabled', function(e) {
        e.marker.closePopup()
    });

    gps.addTo(map);
//END GPS*****************************




//*************************

    map.clicked = 0;   





//var icon3 = new L.Icon({
  //iconUrl: 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-2x-violet.png',
  //shadowUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/0.7.7/images/marker-shadow.png',
  //iconSize: [25, 41],
  //iconAnchor: [12, 41],
  //popupAnchor: [1, -34],
  //shadowSize: [41, 41]
//});

var icon200 = new L.Icon({
  iconUrl: 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-2x-green.png',
  shadowUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/0.7.7/images/marker-shadow.png',
  iconSize: [25, 41],
  iconAnchor: [12, 41],
  popupAnchor: [1, -34],
  shadowSize: [41, 41]
});



var marker100 = L.marker([42.5, -79.0],{
    icon:icon200,
    draggable: true
});



var toggle50 = L.easyButton({
    //position: 'bottomleft',
  states: [{
    stateName: 'add-marker',
    icon: 'fas fa-map-marker-alt fa-lg',
    position: 'bottomleft',
    //icon: 'fa-location-plus',
    title: 'add draggable marker',
    onClick: function(control) {
        marker100.setLatLng(map.getCenter());
      map.addLayer(marker100);
      control.state('remove-marker');
    }
  }, {
    //icon: 'fa-close',
    icon: 'far fa-times-circle fa-lg',
    //icon: 'location-pin-slash',
    stateName: 'remove-marker',
    onClick: function(control) {
      map.removeLayer(marker100);
      control.state('add-marker');
    },
    title: 'remove marker'
  }]
});
//toggle50.setPosition('bottomleft').addTo(map);
toggle50.addTo(map);

// new marker code with street view
marker100.clicked = 0;
marker100.on('click', function(event) {
    marker100.clicked = marker100.clicked + 1;
    setTimeout(function() {
        if (marker100.clicked === 1) {
            var latlng = event.latlng;
            var latlngStr = latlng.lat.toFixed(4) + ", " + latlng.lng.toFixed(4);
            
            // Check if the device is mobile
            var isMobile = /Mobi|Android/i.test(navigator.userAgent);

            // Construct the appropriate URL based on the device type
            var googleMapsUrl = isMobile 
                ? `https://www.google.com/maps/search/?api=1&query=${latlng.lat.toFixed(4)},${latlng.lng.toFixed(4)}`  // Mobile: Open map at coordinates
                : `https://www.google.com/maps?layer=c&cbll=${latlng.lat.toFixed(4)},${latlng.lng.toFixed(4)}`;        // Desktop: Open Street View

            var popupContent = `
                <a href="#" onclick="copyTextToClipboard('${latlngStr}')">${latlngStr}</a><br>
                <a href="${googleMapsUrl}" target="_blank"><br>Open in Google Maps</a>
            `;

            marker100.bindPopup(popupContent).openPopup();              
            marker100.clicked = 0;
        }
    }, 200);
});





//****************end marker1

map.on('dblclick', function(event){
    map.clicked = 0;
    map.zoomIn();
});

//*****************



//************************************
var eraseButton = L.easyButton({
    states: [{
        stateName: 'erase-all',
        icon: 'fas fa-trash-alt fa-lg', // Using Font Awesome 'trash' icon
        position: 'bottomleft',
        title: 'Erase All Layers',
        onClick: function() {
            // Confirmation prompt
            var confirmed = confirm("Are you sure you want to reset the map and clear all progress?");
            if (confirmed) {
                // Clear stored progress
                localStorage.removeItem('mapProgress');

                // Reload the page
                window.location.reload();
            }
        }
    }]
});

eraseButton.addTo(map);

//**************************************



// URL of the custom icon
// Define your custom icon
var customIconHomeUrl = 'https://img.icons8.com/stickers/100/house.png'; // Replace with your Flaticon URL
var customIconHome = L.icon({
    iconUrl: customIconHomeUrl,
    iconSize: [35, 35], // Size of the icon
    iconAnchor: [10, 20], // Point of the icon which will correspond to marker's location
    popupAnchor: [25, -25] // Point from which the popup should open relative to the iconAnchor
});

// Add a marker with the custom icon
var homeMarker = L.marker([43.184512516, -79.254466056], {icon: customIconHome}).addTo(map)
  .bindPopup("Lily Saxon HomeBase");

// Open the popup automatically when the map loads
homeMarker.openPopup();


  var customIcon = L.icon({
            iconUrl: 'https://img.icons8.com/stickers/100/treasure-chest.png', // Replace with the path to your icon image
            iconSize: [32, 32], // Size of the icon
            iconAnchor: [16, 32], // Point of the icon which will correspond to marker's location
            popupAnchor: [0, -32] // Point from which the popup should open relative to the iconAnchor
        });

       var questions = [
            {
                coords: [43.1827522041864, -79.25639937508032],
                question: "Find the 3 Capital letters on the sign at this location; what Country does it represent?",
                answer: "Spain",
                marker: null
            },
            {
                coords: [43.18184336183437, -79.25528038592944],
                question: "What is the # Code on the fire hydrant at this spot?",
                answer: "01048",
                marker: null
            },
            {
                coords: [43.189057538970744, -79.25912709060226],
                question: "Find small keys hidden somewhere at this location. What colour dots are on each key?",
                answer: "red",
                marker: null
            },
            {
                coords: [43.18909597721867, -79.25951156688416],
                question: "Find & open the lock-box at this location (don't skip the cracks!).  What is in it?",
                answer: "Jack",
                marker: null
            },
            
            {
                coords: [43.18991937631887, -79.25852871660115],
                question: "Find and Scan the QR-code found in this location.  What do you see?",
                answer: "lily",
                marker: null
            },
            {
                coords: [43.18806771657462, -79.25711667111199],
                question: "Find a flag at this location.  What country is it? (you get one hint)",
                answer: "Mexico",
                marker: null
            },
            // Add more questions here
            {
                coords: [43.184512516, -79.254466056],
                question: "FINAL MATH: What is the square root of 9, then squared, plus 4?",
                answer: "13",
                marker: null
            }
                    ];


        function addMarker(index) {
    var location = questions[index];
    var marker = L.marker(location.coords, {icon: customIcon}).addTo(map);
    location.marker = marker;

    marker.on('click', function() {
        var userAnswer = prompt(location.question);
        if (userAnswer.toLowerCase() === location.answer.toLowerCase()) {
            alert("Correct!");
            marker.closePopup();

            if (index + 1 < questions.length) {
                localStorage.setItem('mapProgress', index + 1);
                addMarker(index + 1); // Add the next marker
            } else {
                // This is the last question, show the custom popup
                showHoorayPopup();
            }
        } else {
            alert("Incorrect, try again.");
        }
    });
}

// Call addMarker for the first marker initially
addMarker(0);



var savedProgress = localStorage.getItem('mapProgress');
        var progressIndex = savedProgress ? parseInt(savedProgress, 10) : 0;
        for (var i = 0; i <= progressIndex; i++) {
            if (i < questions.length) {
                addMarker(i);
            }
        }
        //addMarker(0); // Initialize first marker
         function resetProgress() {
            localStorage.removeItem('mapProgress');
            alert("Progress reset. Please reload the page.");
        }

       function showHoorayPopup() {
    var popup = document.getElementById('hoorayPopup');
    popup.style.display = 'block';
}

function closeHoorayPopup() {
    var popup = document.getElementById('hoorayPopup');
    popup.style.display = 'none';
}


    </script>
</body>
</html>


	
